<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Missile Command Overdrive</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: rgba(6, 13, 27, .74);
      --line: rgba(118, 198, 255, .32);
      --txt: #e9f6ff;
      --dim: rgba(217, 237, 255, .74);
      --accent: #8df2ff
    }

    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      user-select: none;
      background: #040916;
      color: var(--txt);
      font-family: "Orbitron", "Trebuchet MS", "Segoe UI", sans-serif
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: crosshair
    }

    #hud {
      position: absolute;
      left: 50%;
      bottom: 52px;
      transform: translateX(-50%);
      min-width: 320px;
      max-width: min(700px, 92vw);
      background: var(--bg);
      border: 1px solid var(--line);
      box-shadow: 0 0 22px rgba(74, 156, 230, .35);
      border-radius: 10px;
      padding: 10px 12px;
      line-height: 1.45;
      font-size: 13px;
      letter-spacing: .05em;
      text-transform: uppercase;
      pointer-events: none
    }

    #hud strong {
      color: var(--accent)
    }

    #hud .dim {
      color: var(--dim)
    }

    #help {
      position: absolute;
      left: 16px;
      bottom: 14px;
      background: rgba(4, 10, 20, .62);
      border: 1px solid rgba(126, 180, 230, .25);
      border-radius: 8px;
      padding: 7px 10px;
      font-size: 12px;
      letter-spacing: .05em;
      text-transform: uppercase;
      pointer-events: none
    }

    @media (max-width:780px) {
      #hud {
        min-width: 0;
        max-width: calc(100vw - 22px);
        font-size: 11px;
        padding: 8px;
        bottom: 56px
      }

      #help {
        left: 10px;
        right: 10px;
        bottom: 10px;
        font-size: 10px
      }
    }
  </style>
</head>

<body>
  <canvas id="game" width="1280" height="720"></canvas>
  <div id="hud"></div>
  <div id="help">LMB Fire | H Hell Raiser | C Auto Defense | E EMP | M Mute | +/- Volume | F8 Debug | F9/F10 Export | ]/[ Skip Level | 1-5 Shop | R Restart</div>
  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const hud = document.getElementById('hud');
      const TAU = Math.PI * 2,
        BASE_PLAYER_SPEED = 640;
      const C = {
        skyA: '#040a23',
        skyB: '#12224f',
        skyC: '#130f2f',
        groundA: '#2a2544',
        groundB: '#090a16',
        enemy: '#ffc992',
        fast: '#ffe06a',
        zig: '#ff95f0',
        split: '#ff9f6f',
        heavy: '#ff6b55',
        ufo: '#98ffd3',
        ufoBomb: '#9fe9ff',
        phalanx: '#ffd9a0',
        phalanxGlow: '#fff1c3',
        player: '#b8ffff',
        ember: '#ffb874',
        ion: '#95ecff'
      };
      const S = {
        w: innerWidth,
        h: innerHeight,
        groundY: 0,
        horizonY: 0,
        time: 0,
        last: 0,
        intro: true,
        gameOver: false,
        gameOverSfx: false,
        level: 1,
        score: 0,
        combo: 0,
        maxCombo: 0,
        comboTimer: 0,
        danger: 0,
        wavePause: 2,
        waveTime: 0,
        wavePlan: [],
        spawnI: 0,
        ufoQuota: 0,
        nextUfo: 0,
        raiderQuota: 0,
        nextRaider: 0,
        phalanx: null,
        hellRaiser: null,
        starsA: [],
        starsB: [],
        nebula: [],
        aurora: [],
        clouds: [],
        haze: [],
        mountFar: [],
        mountNear: [],
        bases: [],
        cities: [],
        ufo: [],
        raiders: [],
        demon: null,
        enemy: [],
        player: [],
        expl: [],
        sparks: [],
        smoke: [],
        trails: [],
        debris: [],
        shock: [],
        lightBursts: [],
        weather: {
          mode: 'clear',
          intensity: 0,
          wind: 0,
          particles: [],
          fogBands: [],
          lightningT: 0,
          thunderCd: 0
        },
        mouse: {
          x: 0,
          y: 0
        },
        shake: 0,
        flash: 0,
        auto: false,
        msg: '',
        msgT: 0,
        note: '',
        noteT: 0,
        emp: 1,
        empMax: 3,
        empCd: 0,
        id: 1,
        shop: false,
        shopTimer: 0,
        upgrades: {
          blastScale: 1.0,
          reloadMult: 1.0,
          empScale: 1.0,
          phalanxEff: 1.0
        },
        selectedBase: null,
        floatingTexts: [],
        debug: {
          enabled: false,
          maxEventsPerWave: 120000,
          sessionStartedAt: new Date().toISOString(),
          currentWave: null,
          waveSeq: 0,
          waves: {},
          sessionDrops: 0
        }
      };
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const rand = (a, b) => a + Math.random() * (b - a);
      const lerp = (a, b, t) => a + (b - a) * t;
      const round3 = v => Math.round((Number(v) || 0) * 1000) / 1000;
      const angleDelta = (from, to) => Math.atan2(Math.sin(to - from), Math.cos(to - from));
      const easeOut = t => 1 - Math.pow(1 - clamp(t, 0, 1), 3);
      const easeIn = t => {
        t = clamp(t, 0, 1);
        return t * t * t;
      };
      const mixRgb = (a, b, t) => [
        Math.round(lerp(a[0], b[0], t)),
        Math.round(lerp(a[1], b[1], t)),
        Math.round(lerp(a[2], b[2], t))
      ];
      const rgba = (rgb, a = 1) => `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
      let bloomCanvas = null;
      let bloomCtx = null;
      let grainCanvas = null;
      let grainPattern = null;
      const LIGHT_PALETTE = {
        skyNight: [
          [4, 10, 35],
          [18, 34, 79],
          [19, 15, 47]
        ],
        skyDay: [
          [102, 156, 222],
          [146, 196, 238],
          [232, 191, 146]
        ],
        moon: [236, 246, 255],
        moonGlow: [162, 198, 255],
        sun: [255, 233, 188],
        sunGlow: [255, 208, 146],
        mountFarNight: [
          [30, 40, 78],
          [10, 12, 25]
        ],
        mountFarDay: [
          [82, 106, 150],
          [42, 54, 86]
        ],
        mountNearNight: [
          [40, 42, 65],
          [11, 10, 20]
        ],
        mountNearDay: [
          [98, 110, 142],
          [52, 58, 86]
        ],
        groundNight: [
          [42, 37, 68],
          [9, 10, 22]
        ],
        groundDay: [
          [86, 84, 108],
          [28, 30, 44]
        ]
      };

      function makeNoiseTexture(size = 160) {
        const tex = document.createElement('canvas');
        tex.width = size;
        tex.height = size;
        const tctx = tex.getContext('2d');
        const img = tctx.createImageData(size, size);
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          const v = Math.random() * 255;
          d[i] = v;
          d[i + 1] = v;
          d[i + 2] = v;
          d[i + 3] = 26;
        }
        tctx.putImageData(img, 0, 0);
        return tex;
      }

      function ensureRenderBuffers() {
        if (!bloomCanvas) {
          bloomCanvas = document.createElement('canvas');
          bloomCtx = bloomCanvas.getContext('2d');
        }
        bloomCanvas.width = S.w;
        bloomCanvas.height = S.h;
        if (!grainCanvas) {
          grainCanvas = makeNoiseTexture(160);
          grainPattern = ctx.createPattern(grainCanvas, 'repeat');
        }
      }

      function skyCycle() {
        const cycleSeconds = 840;
        const phase = (S.time % cycleSeconds) / cycleSeconds;
        const wave = (1 - Math.cos(phase * TAU)) * .5;
        const day = wave * wave * (3 - 2 * wave) * .86;
        const twilight = Math.pow(Math.max(0, 1 - Math.abs(wave * 2 - 1)), 1.35);
        return {
          phase,
          day,
          night: 1 - day,
          twilight
        };
      }

      const moonTexCache = new Map();

      function moonTexture(radius) {
        const r = Math.max(24, Math.round(radius));
        const key = String(r);
        if (moonTexCache.has(key)) return moonTexCache.get(key);
        const tex = document.createElement('canvas');
        tex.width = r * 2;
        tex.height = r * 2;
        const tctx = tex.getContext('2d');
        const w = tex.width;
        const h = tex.height;
        const cx = w * .5;
        const cy = h * .5;
        const rr = r;
        const lightDirX = -.58;
        const lightDirY = -.35;
        const hash2 = (x, y) => {
          const v = Math.sin(x * 127.1 + y * 311.7) * 43758.5453123;
          return v - Math.floor(v);
        };
        const noise2 = (x, y) => {
          const xi = Math.floor(x);
          const yi = Math.floor(y);
          const xf = x - xi;
          const yf = y - yi;
          const u = xf * xf * (3 - 2 * xf);
          const v = yf * yf * (3 - 2 * yf);
          const a = hash2(xi, yi);
          const b = hash2(xi + 1, yi);
          const c = hash2(xi, yi + 1);
          const d = hash2(xi + 1, yi + 1);
          const ab = lerp(a, b, u);
          const cd = lerp(c, d, u);
          return lerp(ab, cd, v);
        };
        const img = tctx.createImageData(w, h);
        const data = img.data;
        let p = 0;
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const dx = (x + .5 - cx) / rr;
            const dy = (y + .5 - cy) / rr;
            const d = Math.hypot(dx, dy);
            if (d > 1) {
              p += 4;
              continue;
            }
            const nz1 = noise2(dx * 4.6 + 7.2, dy * 4.6 + 2.1);
            const nz2 = noise2(dx * 10.3 + 19.4, dy * 10.3 + 3.7);
            const nz3 = noise2(dx * 18.7 + 1.8, dy * 18.7 + 8.3);
            const nz4 = noise2(dx * 27.7 + 5.9, dy * 27.7 + 12.6);
            const broad = nz1 * .72 + nz2 * .28;
            const fine = nz3 - .5;
            const micro = nz4 - .5;
            const mariaMask = Math.max(0, (broad - .5) / .38);
            const maria = mariaMask * mariaMask * (.24 + nz2 * .22);
            const dot = Math.max(0, -(dx * lightDirX + dy * lightDirY));
            const limb = d * d;
            const albedo = .79 + fine * .2 + micro * .11 - maria * 1.08;
            const shade = .62 + dot * .31 - limb * .24;
            const tone = clamp(albedo * shade, .24, 1);
            const contrast = clamp((tone - .5) * 1.46 + .5, .14, 1);
            const rch = Math.round(174 * contrast + 14);
            const gch = Math.round(190 * contrast + 18);
            const bch = Math.round(216 * contrast + 22);
            const edge = clamp((1 - d) / .04, 0, 1);
            data[p++] = rch;
            data[p++] = gch;
            data[p++] = bch;
            data[p++] = Math.round(255 * edge);
          }
        }
        tctx.putImageData(img, 0, 0);
        const rim = tctx.createRadialGradient(cx - rr * .34, cy - rr * .36, rr * .14, cx, cy, rr * 1.02);
        rim.addColorStop(0, 'rgba(255,255,255,.18)');
        rim.addColorStop(.72, 'rgba(255,255,255,0)');
        rim.addColorStop(1, 'rgba(58,78,118,.28)');
        tctx.globalCompositeOperation = 'screen';
        tctx.fillStyle = rim;
        tctx.beginPath();
        tctx.arc(cx, cy, rr * .99, 0, TAU);
        tctx.fill();
        tctx.globalCompositeOperation = 'source-over';
        moonTexCache.set(key, tex);
        return tex;
      }

      const pick = (arr) => {
        let sum = 0;
        for (const x of arr)
          if (x.w > 0) sum += x.w;
        if (sum <= 0) return arr[0]?.v ?? null;
        let r = Math.random() * sum;
        for (const x of arr) {
          if (x.w <= 0) continue;
          r -= x.w;
          if (r <= 0) return x.v;
        }
        return arr[arr.length - 1].v;
      };
      const vColor = v => v === 'fast' ? C.fast : v === 'zig' ? C.zig : v === 'split' || v === 'shard' ? C.split : v === 'heavy' ? C.heavy : v === 'ufoBomb' ? C.ufoBomb : v === 'stealth' ? '#334c9c' : v === 'decoy' ? '#44ff66' : v === 'cruise' ? '#7dffd8' : v === 'carrier' ? '#ffb07f' : v === 'drone' ? '#9cf7ff' : v === 'spit' ? '#ff8c6a' : v === 'hell' ? '#ff3a2d' : C.enemy;
      const vValue = v => v === 'fast' ? 90 : v === 'zig' ? 120 : v === 'split' ? 170 : v === 'shard' ? 80 : v === 'heavy' ? 210 : v === 'ufoBomb' ? 115 : v === 'stealth' ? 140 : v === 'decoy' ? 25 : v === 'cruise' ? 190 : v === 'carrier' ? 320 : v === 'drone' ? 95 : v === 'spit' ? 70 : v === 'hell' ? 180 : 75;
      const vRes = v => v === 'heavy' ? 0.38 : v === 'zig' ? 0.2 : v === 'split' ? 0.22 : v === 'fast' ? 0.14 : v === 'ufoBomb' ? 0.1 : v === 'stealth' ? 0.05 : v === 'cruise' ? 0.2 : v === 'carrier' ? 0.46 : v === 'drone' ? 0.12 : v === 'spit' ? 0.1 : v === 'hell' ? 0.18 : 0.08;
      const vSpeed = v => {
        const L = S.level;
        return v === 'fast' ? 165 + L * 16 : v === 'zig' ? 116 + L * 12 : v === 'split' ? 112 + L * 10 : v === 'shard' ? 190 + L * 18 : v === 'heavy' ? 92 + L * 9 : v === 'ufoBomb' ? 150 + L * 12 : v === 'stealth' ? 100 + L * 10 : v === 'decoy' ? 120 + L * 11 : v === 'cruise' ? 145 + L * 12 : v === 'carrier' ? 82 + L * 8 : v === 'drone' ? 180 + L * 16 : v === 'spit' ? 168 + L * 14 : v === 'hell' ? 196 + L * 14 : 105 + L * 11;
      };

      function note(t, d = 1.7) {
        S.note = t;
        S.noteT = d;
      }
      let secretCode = '';

      function jumpLevel(delta) {
        if (S.intro || S.gameOver) resetGame();
        S.shop = false;
        debugRecord('wave_jump', {
          fromLevel: S.level,
          delta
        });
        S.level = Math.max(1, S.level + delta);
        startWave(.7);
        S.msg = `Jumped to Wave ${S.level}`;
        S.msgT = 1.2;
      }

      function targetSnapshot(t) {
        if (!t) return null;
        const base = {
          type: t.type ?? 'unknown',
          x: round3(t.x ?? 0),
          y: round3(t.y ?? 0)
        };
        if (t.type === 'city') base.id = t.ref?.id ?? null;
        else if (t.type === 'base') base.id = t.ref?.id ?? null;
        else if (t.type === 'phalanx') base.id = 'PHALANX';
        else if (t.type === 'hellRaiser') base.id = 'HELL_RAISER';
        else base.id = t.ref?.id ?? null;
        return base;
      }

      function debugCreateWave(level, meta = {}) {
        const d = S.debug,
          key = `W${++d.waveSeq}-L${level}`;
        const wave = {
          key,
          seq: d.waveSeq,
          level,
          startTime: round3(S.time),
          startIso: new Date().toISOString(),
          endTime: null,
          endIso: null,
          endReason: null,
          meta,
          dropped: 0,
          events: [],
          stats: {
            enemySpawn: {},
            enemyVehicleSpawn: {},
            enemyKilled: {},
            enemyImpact: {},
            enemyTargetType: {},
            defenseShots: {
              manual: 0,
              auto: 0,
              phalanx: 0,
              hellRaiser: 0
            },
            defenseBursts: {
              phalanx: 0,
              hellRaiser: 0
            },
            assetsLost: {
              cities: 0,
              bases: 0,
              phalanx: 0,
              hellRaiser: 0
            },
            autoScan: {
              cycles: 0,
              enemy: {
                covered: 0,
                noIntercept: 0,
                late: 0,
                conflict: 0
              },
              ufo: {
                noIntercept: 0,
                conflict: 0
              }
            }
          }
        };
        d.waves[key] = wave;
        d.currentWave = key;
        return wave;
      }

      function debugCurrentWave() {
        const key = S.debug.currentWave;
        return key ? S.debug.waves[key] ?? null : null;
      }

      function debugEnsureWave(level = S.level) {
        if (!S.debug.enabled) return null;
        let wave = debugCurrentWave();
        if (!wave || wave.endReason || wave.level !== level) wave = debugCreateWave(level, {
          trigger: 'implicit'
        });
        return wave;
      }

      function debugInc(map, key, delta = 1, wave = null) {
        const w = wave ?? debugEnsureWave();
        if (!w || !w.stats?.[map]) return;
        w.stats[map][key] = (w.stats[map][key] ?? 0) + delta;
      }

      function debugRecord(type, payload = {}, wave = null) {
        if (!S.debug.enabled) return;
        const w = wave ?? debugEnsureWave();
        if (!w) return;
        if (w.events.length >= S.debug.maxEventsPerWave) {
          w.dropped++;
          S.debug.sessionDrops++;
          return;
        }
        w.events.push({
          t: round3(S.time),
          type,
          ...payload
        });
      }

      function debugStartWave(level, meta = {}) {
        if (!S.debug.enabled) return;
        const cur = debugCurrentWave();
        if (cur && !cur.endReason) {
          cur.endTime = round3(S.time);
          cur.endIso = new Date().toISOString();
          cur.endReason = 'wave_transition';
        }
        const w = debugCreateWave(level, meta);
        debugRecord('wave_start', {
          level,
          ...meta
        }, w);
      }

      function debugFinalizeWave(reason = 'unknown', extra = {}) {
        if (!S.debug.enabled) return;
        const w = debugCurrentWave();
        if (!w || w.endReason) return;
        debugRecord('wave_end', {
          reason,
          ...extra
        }, w);
        w.endTime = round3(S.time);
        w.endIso = new Date().toISOString();
        w.endReason = reason;
      }

      function debugExport(scope = 'session') {
        const d = S.debug,
          all = Object.values(d.waves).sort((a, b) => a.seq - b.seq),
          waves = scope === 'wave' ? (debugCurrentWave() ? [debugCurrentWave()] : all.slice(-1)) : all,
          totalEvents = all.reduce((n, w) => n + (w.events?.length ?? 0), 0),
          data = {
            schema: 'mc-overdrive.debug.v1',
            generatedAt: new Date().toISOString(),
            session: {
              startedAt: d.sessionStartedAt,
              currentLevel: S.level,
              gameTime: round3(S.time),
              enabled: d.enabled,
              waves: all.length,
              totalEvents,
              dropped: d.sessionDrops
            },
            scope,
            waves
          };
        const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: 'application/json'
          }),
          a = document.createElement('a'),
          stamp = new Date().toISOString().replace(/[:.]/g, '-');
        a.href = URL.createObjectURL(blob);
        a.download = `mc-overdrive-debug-${scope}-${stamp}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(a.href);
        note(scope === 'wave' ? 'Wave debug export ready' : 'Session debug export ready', 1.15);
      }

      function debugToggle(force = null) {
        const d = S.debug,
          next = force === null ? !d.enabled : !!force;
        if (next === d.enabled) return;
        if (!next) {
          debugRecord('debug_disabled', {
            level: S.level
          });
          d.enabled = false;
          S.msg = 'Debug telemetry OFF';
          S.msgT = 1.0;
          return;
        }
        d.enabled = true;
        debugStartWave(S.level, {
          trigger: 'toggle_on'
        });
        debugRecord('debug_enabled', {
          level: S.level
        });
        S.msg = 'Debug telemetry ON';
        S.msgT = 1.0;
      }

      function interceptorSpeed(mult = 1) {
        const lvlBoost = 1 + Math.min(1.7, Math.max(0, S.level - 1) * .022),
          weatherDrag = S.weather?.mode === 'storm' ? (1 - clamp((S.weather.intensity ?? 0) * .08, 0, .08)) : 1;
        return BASE_PLAYER_SPEED * lvlBoost * weatherDrag * mult;
      }

      function hellRaiserTop(hr = S.hellRaiser) {
        if (!hr) return { x: S.w * .5, y: S.groundY - 8 };
        return {
          x: hr.x,
          y: hr.y - 7 - hr.lift * 72
        };
      }

      function hellRaiserVulnerable(hr = S.hellRaiser) {
        if (!hr || hr.destroyed) return false;
        return hr.state === 'opening' || hr.state === 'rising' || hr.state === 'active' || hr.state === 'lowering';
      }

      function hellRaiserStatus(hr = S.hellRaiser) {
        if (!hr) return '--';
        if (hr.destroyed) return 'DESTROYED';
        if (hr.state === 'hidden') return hr.cool > 0 ? 'REARM' : 'STANDBY';
        if (hr.state === 'opening' || hr.state === 'rising') return 'DEPLOYING';
        if (hr.state === 'active') return 'BARRAGE';
        if (hr.state === 'lowering' || hr.state === 'closing' || hr.state === 'cooldown') return 'RETRACT';
        return hr.state.toUpperCase();
      }

      function mkAudio() {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return {
          unlock() { },
          update() { },
          launch() { },
          hellRaiser() { },
          enemyLaunch() { },
          hit() { },
          impact() { },
          city() { },
          emp() { },
          wave() { },
          over() { },
          incoming() { },
          phalanx() { },
          nearMiss() { },
          thunder() { },
          setVolume(v) { },
          getVolume() { return 1.0; },
          toggleMute() { },
          isMuted() { return false; }
        };
        const ac = new AC(),
          master = ac.createGain(),
          music = ac.createGain(),
          sfx = ac.createGain(),
          comp = ac.createDynamicsCompressor(),
          reverb = ac.createConvolver(),
          reverbSend = ac.createGain(),
          reverbWet = ac.createGain();
        let vol = 1.0;
        let muted = false;
        let gameOverVol = false;
        const baseVolume = .54;
        const updateMasterGain = () => {
          if (!ac) return;
          const target = muted ? 0 : (gameOverVol ? .32 : baseVolume) * vol;
          master.gain.setTargetAtTime(target, ac.currentTime, 0.05);
        };
        updateMasterGain();
        music.gain.value = .12;
        sfx.gain.value = .8;
        comp.threshold.value = -19;
        comp.knee.value = 24;
        comp.ratio.value = 2.6;
        comp.attack.value = .006;
        comp.release.value = .2;
        const makeImpulse = () => {
          const len = Math.floor(ac.sampleRate * 1.65),
            b = ac.createBuffer(2, len, ac.sampleRate);
          for (let ch = 0; ch < 2; ch++) {
            const d = b.getChannelData(ch);
            for (let i = 0; i < len; i++) {
              const t = i / len;
              d[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, 2.35);
            }
          }
          return b;
        };
        reverb.buffer = makeImpulse();
        reverbSend.gain.value = .14;
        reverbWet.gain.value = .22;
        music.connect(comp);
        sfx.connect(comp);
        sfx.connect(reverbSend);
        reverbSend.connect(reverb);
        reverb.connect(reverbWet);
        reverbWet.connect(comp);
        comp.connect(master);
        master.connect(ac.destination);
        const nb = (() => {
          const len = ac.sampleRate,
            b = ac.createBuffer(1, len, ac.sampleRate),
            d = b.getChannelData(0);
          for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / len);
          return b;
        })();
        let on = ac.state === 'running',
          amb = false,
          beat = 0,
          warnPulse = 0,
          dangerVoice = null,
          dangerGain = null,
          dangerVib = null,
          phGain = null,
          phPan = null,
          stormGain = null,
          stormBand = null,
          stormPan = null;
        const pan = n => {
          if (ac.createStereoPanner) {
            const p = ac.createStereoPanner();
            p.pan.value = clamp((n - .5) * 1.9, -1, 1);
            return p;
          }
          return ac.createGain();
        };
        const run = f => {
          if (!on) return;
          if (ac.state === 'suspended') {
            ac.resume().then(() => f(ac.currentTime)).catch(() => { });
            return;
          }
          f(ac.currentTime);
        };
        const unlock = () => {
          if (!on) {
            ac.resume().catch(() => { });
            on = true;
          }
          if (!amb) {
            amb = true;
            run(now => {
              const a = ac.createOscillator(),
                b = ac.createOscillator(),
                c = ac.createOscillator(),
                l = ac.createOscillator();
              a.type = 'triangle';
              b.type = 'sawtooth';
              c.type = 'sine';
              a.frequency.value = 62;
              b.frequency.value = 93;
              c.frequency.value = 124;
              l.frequency.value = .09;
              const lf = ac.createGain();
              lf.gain.value = 11;
              const lp = ac.createBiquadFilter();
              lp.type = 'lowpass';
              lp.frequency.value = 530;
              lp.Q.value = .6;
              const ga = ac.createGain(),
                gb = ac.createGain(),
                gc = ac.createGain();
              ga.gain.value = .07;
              gb.gain.value = .035;
              gc.gain.value = .03;
              l.connect(lf);
              lf.connect(lp.frequency);
              a.connect(ga);
              b.connect(gb);
              c.connect(gc);
              ga.connect(lp);
              gb.connect(lp);
              gc.connect(lp);
              lp.connect(music);
              const airy = ac.createBufferSource();
              airy.buffer = nb;
              airy.loop = true;
              const af = ac.createBiquadFilter();
              af.type = 'bandpass';
              af.frequency.value = 1400;
              const ag = ac.createGain();
              ag.gain.value = .014;
              airy.connect(af);
              af.connect(ag);
              ag.connect(music);
              dangerVoice = ac.createOscillator();
              dangerVoice.type = 'triangle';
              dangerVoice.frequency.value = 170;
              dangerVib = ac.createOscillator();
              dangerVib.frequency.value = 6.1;
              const dvg = ac.createGain();
              dvg.gain.value = 11;
              dangerGain = ac.createGain();
              dangerGain.gain.value = .0001;
              const df = ac.createBiquadFilter();
              df.type = 'bandpass';
              df.frequency.value = 1080;
              df.Q.value = .45;
              dangerVib.connect(dvg);
              dvg.connect(dangerVoice.frequency);
              dangerVoice.connect(df);
              df.connect(dangerGain);
              dangerGain.connect(sfx);
              const phHum = ac.createOscillator(),
                phBuzz = ac.createOscillator(),
                phLfo = ac.createOscillator(),
                phNoise = ac.createBufferSource();
              phHum.type = 'square';
              phHum.frequency.value = 108;
              phBuzz.type = 'sawtooth';
              phBuzz.frequency.value = 610;
              phLfo.type = 'triangle';
              phLfo.frequency.value = 28;
              phNoise.buffer = nb;
              phNoise.loop = true;
              const phLfg = ac.createGain();
              phLfg.gain.value = 62;
              phLfo.connect(phLfg);
              phLfg.connect(phBuzz.frequency);
              const phHg = ac.createGain(),
                phBg = ac.createGain(),
                phNg = ac.createGain();
              phHg.gain.value = .24;
              phBg.gain.value = .22;
              phNg.gain.value = .28;
              const phBpf = ac.createBiquadFilter(),
                phHpf = ac.createBiquadFilter();
              phBpf.type = 'bandpass';
              phBpf.frequency.value = 1120;
              phBpf.Q.value = .9;
              phHpf.type = 'highpass';
              phHpf.frequency.value = 1900;
              phGain = ac.createGain();
              phGain.gain.value = .0001;
              phPan = ac.createStereoPanner ? ac.createStereoPanner() : ac.createGain();
              phHum.connect(phHg);
              phHg.connect(phGain);
              phBuzz.connect(phBpf);
              phBpf.connect(phBg);
              phBg.connect(phGain);
              phNoise.connect(phHpf);
              phHpf.connect(phNg);
              phNg.connect(phGain);
              phGain.connect(phPan);
              phPan.connect(sfx);
              const storm = ac.createBufferSource();
              storm.buffer = nb;
              storm.loop = true;
              stormBand = ac.createBiquadFilter();
              stormBand.type = 'bandpass';
              stormBand.frequency.value = 820;
              stormBand.Q.value = .38;
              stormGain = ac.createGain();
              stormGain.gain.value = .0001;
              stormPan = ac.createStereoPanner ? ac.createStereoPanner() : ac.createGain();
              storm.connect(stormBand);
              stormBand.connect(stormGain);
              stormGain.connect(stormPan);
              stormPan.connect(sfx);
              a.start(now);
              b.start(now);
              c.start(now);
              l.start(now);
              airy.start(now);
              dangerVoice.start(now);
              dangerVib.start(now);
              phHum.start(now);
              phBuzz.start(now);
              phLfo.start(now);
              phNoise.start(now);
              storm.start(now);
              beat = now + .1;
            });
          }
        };
        const launch = n => run(now => {
          const noise = ac.createBufferSource();
          noise.buffer = nb;
          const bp = ac.createBiquadFilter();
          bp.type = 'bandpass';
          bp.frequency.value = 1900;
          bp.Q.value = 2.5;
          const ng = ac.createGain();
          ng.gain.setValueAtTime(.0001, now);
          ng.gain.exponentialRampToValueAtTime(.3, now + .018);
          ng.gain.exponentialRampToValueAtTime(.02, now + .24);
          const o = ac.createOscillator();
          o.type = 'sawtooth';
          o.frequency.setValueAtTime(250, now);
          o.frequency.exponentialRampToValueAtTime(1060, now + .12);
          const og = ac.createGain();
          og.gain.setValueAtTime(.28, now);
          og.gain.exponentialRampToValueAtTime(.014, now + .2);
          const p = pan(n);
          noise.connect(bp);
          bp.connect(ng);
          ng.connect(p);
          o.connect(og);
          og.connect(p);
          p.connect(sfx);
          noise.start(now);
          noise.stop(now + .26);
          o.start(now);
          o.stop(now + .22);
        });
        const hellRaiser = (n, inten = .8) => run(now => {
          const p = pan(n),
            pulse = clamp(inten, .2, 1.4);
          const chirp = ac.createOscillator(),
            cg = ac.createGain();
          chirp.type = 'triangle';
          chirp.frequency.setValueAtTime(1800 + pulse * 620, now);
          chirp.frequency.exponentialRampToValueAtTime(820 + pulse * 180, now + .07);
          cg.gain.setValueAtTime(.0001, now);
          cg.gain.exponentialRampToValueAtTime(.22 * pulse, now + .004);
          cg.gain.exponentialRampToValueAtTime(.001, now + .085);
          const zing = ac.createOscillator(),
            zg = ac.createGain();
          zing.type = 'square';
          zing.frequency.setValueAtTime(2500 + pulse * 700, now);
          zing.frequency.exponentialRampToValueAtTime(1400, now + .05);
          zg.gain.setValueAtTime(.0001, now);
          zg.gain.exponentialRampToValueAtTime(.13 * pulse, now + .003);
          zg.gain.exponentialRampToValueAtTime(.001, now + .07);
          const fizz = ac.createBufferSource(),
            hp = ac.createBiquadFilter(),
            fg = ac.createGain();
          fizz.buffer = nb;
          hp.type = 'highpass';
          hp.frequency.value = 1900;
          fg.gain.setValueAtTime(.0001, now);
          fg.gain.exponentialRampToValueAtTime(.17 * pulse, now + .004);
          fg.gain.exponentialRampToValueAtTime(.001, now + .09);
          chirp.connect(cg);
          cg.connect(p);
          zing.connect(zg);
          zg.connect(p);
          fizz.connect(hp);
          hp.connect(fg);
          fg.connect(p);
          p.connect(sfx);
          chirp.start(now);
          zing.start(now);
          fizz.start(now);
          chirp.stop(now + .09);
          zing.stop(now + .08);
          fizz.stop(now + .1);
        });
        const enemyLaunch = n => run(now => {
          const o = ac.createOscillator();
          o.type = 'square';
          o.frequency.setValueAtTime(140, now);
          o.frequency.exponentialRampToValueAtTime(90, now + .23);
          const g = ac.createGain();
          g.gain.setValueAtTime(.22, now);
          g.gain.exponentialRampToValueAtTime(.01, now + .24);
          const p = pan(n);
          o.connect(g);
          g.connect(p);
          p.connect(sfx);
          o.start(now);
          o.stop(now + .26);
        });
        const incoming = (n, inten = .55) => run(now => {
          const o = ac.createOscillator(),
            g = ac.createGain(),
            p = pan(n);
          o.type = 'triangle';
          o.frequency.setValueAtTime(520 + inten * 200, now);
          o.frequency.exponentialRampToValueAtTime(260, now + .18);
          g.gain.setValueAtTime(.0001, now);
          g.gain.exponentialRampToValueAtTime(.13 + inten * .12, now + .02);
          g.gain.exponentialRampToValueAtTime(.001, now + .22);
          o.connect(g);
          g.connect(p);
          p.connect(sfx);
          o.start(now);
          o.stop(now + .24);
        });
        const phalanx = (n, inten = .7) => run(now => {
          const p = pan(n),
            pulse = Math.max(.24, Math.min(1.15, inten));
          const mech = ac.createOscillator(),
            mg = ac.createGain();
          mech.type = 'square';
          mech.frequency.setValueAtTime(105 + pulse * 22, now);
          mg.gain.setValueAtTime(.0001, now);
          mg.gain.exponentialRampToValueAtTime(.24 * pulse, now + .004);
          mg.gain.exponentialRampToValueAtTime(.001, now + .115);
          const buzz = ac.createOscillator(),
            bg = ac.createGain(),
            bp = ac.createBiquadFilter();
          buzz.type = 'sawtooth';
          buzz.frequency.setValueAtTime(640 + pulse * 210, now);
          buzz.frequency.exponentialRampToValueAtTime(470, now + .11);
          bp.type = 'bandpass';
          bp.frequency.value = 980;
          bp.Q.value = 1.2;
          bg.gain.setValueAtTime(.0001, now);
          bg.gain.exponentialRampToValueAtTime(.18 * pulse, now + .004);
          bg.gain.exponentialRampToValueAtTime(.001, now + .115);
          const nz = ac.createBufferSource(),
            hp = ac.createBiquadFilter(),
            ng = ac.createGain();
          nz.buffer = nb;
          hp.type = 'highpass';
          hp.frequency.value = 1900;
          ng.gain.setValueAtTime(.0001, now);
          ng.gain.exponentialRampToValueAtTime(.34 * pulse, now + .004);
          ng.gain.exponentialRampToValueAtTime(.001, now + .115);
          mech.connect(mg);
          mg.connect(p);
          buzz.connect(bp);
          bp.connect(bg);
          bg.connect(p);
          nz.connect(hp);
          hp.connect(ng);
          ng.connect(p);
          p.connect(sfx);
          mech.start(now);
          buzz.start(now);
          nz.start(now);
          mech.stop(now + .12);
          buzz.stop(now + .12);
          nz.stop(now + .12);
        });
        const hit = (n, s = .6) => run(now => {
          const t = ac.createOscillator();
          t.type = 'triangle';
          t.frequency.setValueAtTime(670, now);
          t.frequency.exponentialRampToValueAtTime(180, now + .3);
          const tg = ac.createGain();
          tg.gain.setValueAtTime(.23 + s * .14, now);
          tg.gain.exponentialRampToValueAtTime(.015, now + .32);
          const noise = ac.createBufferSource();
          noise.buffer = nb;
          const hp = ac.createBiquadFilter();
          hp.type = 'highpass';
          hp.frequency.value = 1200;
          const ng = ac.createGain();
          ng.gain.setValueAtTime(.18 + s * .08, now);
          ng.gain.exponentialRampToValueAtTime(.01, now + .25);
          const p = pan(n);
          t.connect(tg);
          tg.connect(p);
          noise.connect(hp);
          hp.connect(ng);
          ng.connect(p);
          p.connect(sfx);
          t.start(now);
          t.stop(now + .35);
          noise.start(now);
          noise.stop(now + .26);
        });
        const impact = (n, heavy = false) => run(now => {
          const noise = ac.createBufferSource();
          noise.buffer = nb;
          const lp = ac.createBiquadFilter();
          lp.type = 'lowpass';
          lp.frequency.setValueAtTime(1200, now);
          lp.frequency.exponentialRampToValueAtTime(heavy ? 180 : 260, now + .46);
          const ng = ac.createGain();
          ng.gain.setValueAtTime(heavy ? .52 : .42, now);
          ng.gain.exponentialRampToValueAtTime(.02, now + .56);
          const sub = ac.createOscillator();
          sub.type = 'sine';
          sub.frequency.setValueAtTime(heavy ? 82 : 95, now);
          sub.frequency.exponentialRampToValueAtTime(heavy ? 34 : 44, now + .55);
          const sg = ac.createGain();
          sg.gain.setValueAtTime(heavy ? .38 : .28, now);
          sg.gain.exponentialRampToValueAtTime(.01, now + .58);
          const p = pan(n);
          noise.connect(lp);
          lp.connect(ng);
          ng.connect(p);
          sub.connect(sg);
          sg.connect(p);
          p.connect(sfx);
          noise.start(now);
          noise.stop(now + .58);
          sub.start(now);
          sub.stop(now + .62);
          if (heavy) {
            const sh = ac.createBufferSource(),
              hf = ac.createBiquadFilter(),
              hg = ac.createGain();
            sh.buffer = nb;
            hf.type = 'highpass';
            hf.frequency.value = 900;
            hg.gain.setValueAtTime(.18, now);
            hg.gain.exponentialRampToValueAtTime(.001, now + .75);
            sh.connect(hf);
            hf.connect(hg);
            hg.connect(p);
            sh.start(now + .03);
            sh.stop(now + .78);
          }
        });
        const city = n => run(now => {
          for (let i = 0; i < 4; i++) {
            const t = now + i * .06,
              o = ac.createOscillator(),
              g = ac.createGain(),
              p = pan(n),
              f = 260 - i * 22;
            o.type = i % 2 ? 'sawtooth' : 'square';
            o.frequency.setValueAtTime(f, t);
            o.frequency.exponentialRampToValueAtTime(Math.max(40, f * .24), t + .26);
            g.gain.setValueAtTime(.2, t);
            g.gain.exponentialRampToValueAtTime(.01, t + .3);
            o.connect(g);
            g.connect(p);
            p.connect(sfx);
            o.start(t);
            o.stop(t + .32);
          }
        });
        const emp = () => run(now => {
          const o = ac.createOscillator(),
            g = ac.createGain();
          o.type = 'triangle';
          o.frequency.setValueAtTime(220, now);
          o.frequency.exponentialRampToValueAtTime(1320, now + .17);
          o.frequency.exponentialRampToValueAtTime(150, now + .82);
          g.gain.setValueAtTime(.0001, now);
          g.gain.exponentialRampToValueAtTime(.48, now + .03);
          g.gain.exponentialRampToValueAtTime(.02, now + .9);
          o.connect(g);
          g.connect(sfx);
          const n = ac.createBufferSource(),
            hp = ac.createBiquadFilter(),
            ng = ac.createGain();
          n.buffer = nb;
          hp.type = 'highpass';
          hp.frequency.value = 1600;
          ng.gain.setValueAtTime(.3, now);
          ng.gain.exponentialRampToValueAtTime(.015, now + .8);
          n.connect(hp);
          hp.connect(ng);
          ng.connect(sfx);
          o.start(now);
          o.stop(now + .95);
          n.start(now);
          n.stop(now + .9);
        });
        const wave = () => run(now => {
          for (let i = 0; i < 3; i++) {
            const t = now + i * .09,
              o = ac.createOscillator(),
              g = ac.createGain();
            o.type = 'triangle';
            o.frequency.setValueAtTime(320 + i * 100, t);
            o.frequency.exponentialRampToValueAtTime(220 + i * 50, t + .23);
            g.gain.setValueAtTime(.24, t);
            g.gain.exponentialRampToValueAtTime(.01, t + .25);
            o.connect(g);
            g.connect(sfx);
            o.start(t);
            o.stop(t + .27);
          }
        });
        const over = () => run(now => {
          const o = ac.createOscillator(),
            g = ac.createGain();
          o.type = 'sawtooth';
          o.frequency.setValueAtTime(170, now);
          o.frequency.exponentialRampToValueAtTime(42, now + 1.2);
          g.gain.setValueAtTime(.32, now);
          g.gain.exponentialRampToValueAtTime(.01, now + 1.25);
          o.connect(g);
          g.connect(sfx);
          o.start(now);
          o.stop(now + 1.3);
        });
        const nearMiss = (n, inten = .75) => run(now => {
          const p = pan(n),
            whoosh = ac.createBufferSource(),
            bp = ac.createBiquadFilter(),
            ng = ac.createGain();
          whoosh.buffer = nb;
          bp.type = 'bandpass';
          bp.frequency.setValueAtTime(1700 + inten * 600, now);
          bp.frequency.exponentialRampToValueAtTime(480, now + .25);
          bp.Q.value = 1.6;
          ng.gain.setValueAtTime(.0001, now);
          ng.gain.exponentialRampToValueAtTime(.22 + inten * .18, now + .03);
          ng.gain.exponentialRampToValueAtTime(.001, now + .28);
          whoosh.connect(bp);
          bp.connect(ng);
          ng.connect(p);
          const s = ac.createOscillator(),
            sg = ac.createGain();
          s.type = 'triangle';
          s.frequency.setValueAtTime(760 + inten * 260, now);
          s.frequency.exponentialRampToValueAtTime(120, now + .22);
          sg.gain.setValueAtTime(.08 + inten * .08, now);
          sg.gain.exponentialRampToValueAtTime(.001, now + .24);
          s.connect(sg);
          sg.connect(p);
          p.connect(sfx);
          whoosh.start(now);
          whoosh.stop(now + .3);
          s.start(now);
          s.stop(now + .25);
        });
        const thunder = (n = .5, inten = .7) => run(now => {
          const p = pan(n),
            rumble = ac.createBufferSource(),
            lp = ac.createBiquadFilter(),
            ng = ac.createGain();
          rumble.buffer = nb;
          lp.type = 'lowpass';
          lp.frequency.setValueAtTime(620, now);
          lp.frequency.exponentialRampToValueAtTime(120, now + 1.6);
          ng.gain.setValueAtTime(.0001, now);
          ng.gain.exponentialRampToValueAtTime(.34 + inten * .32, now + .09);
          ng.gain.exponentialRampToValueAtTime(.012, now + 1.8);
          rumble.connect(lp);
          lp.connect(ng);
          ng.connect(p);
          const sub = ac.createOscillator(),
            sg = ac.createGain();
          sub.type = 'sine';
          sub.frequency.setValueAtTime(58 + inten * 18, now);
          sub.frequency.exponentialRampToValueAtTime(31, now + 1.8);
          sg.gain.setValueAtTime(.22 + inten * .2, now);
          sg.gain.exponentialRampToValueAtTime(.008, now + 1.9);
          sub.connect(sg);
          sg.connect(p);
          p.connect(sfx);
          rumble.start(now);
          rumble.stop(now + 1.9);
          sub.start(now);
          sub.stop(now + 1.95);
        });
        const beatHit = (t, inten, lvl) => {
          const k = ac.createOscillator(),
            kg = ac.createGain();
          k.type = 'sine';
          k.frequency.setValueAtTime(92 + lvl * 2, t);
          k.frequency.exponentialRampToValueAtTime(46, t + .16);
          kg.gain.setValueAtTime(.11 + inten * .16, t);
          kg.gain.exponentialRampToValueAtTime(.01, t + .2);
          k.connect(kg);
          kg.connect(music);
          k.start(t);
          k.stop(t + .22);
          if (inten > .58) {
            const c = ac.createOscillator(),
              cg = ac.createGain();
            c.type = 'triangle';
            c.frequency.setValueAtTime(220 + inten * 90, t);
            c.frequency.exponentialRampToValueAtTime(145, t + .12);
            cg.gain.setValueAtTime(.014 + inten * .02, t);
            cg.gain.exponentialRampToValueAtTime(.001, t + .13);
            c.connect(cg);
            cg.connect(music);
            c.start(t);
            c.stop(t + .14);
          }
        };
        const update = inf => {
          if (!on || !amb) return;
          const now = ac.currentTime,
            inten = clamp(inf.danger * .78 + inf.level * .035, 0, 1),
            lowAmmo = !!inf.lowAmmo,
            weather = clamp(inf.weather ?? 0, 0, 1);
          music.gain.setTargetAtTime(.07 + inten * .22, now, .12);
          reverbSend.gain.setTargetAtTime(.1 + inten * .08 + weather * .1, now, .2);
          reverbWet.gain.setTargetAtTime(.2 + inten * .06, now, .2);
          if (gameOverVol !== !!inf.gameOver) {
            gameOverVol = !!inf.gameOver;
            updateMasterGain();
          }
          if (dangerGain && dangerVoice) {
            const dg = inf.gameOver ? 0 : clamp((inf.danger - .34) * .32 + (lowAmmo ? .05 : 0), 0, .25);
            dangerGain.gain.setTargetAtTime(Math.max(.0001, dg), now, .08);
            dangerVoice.frequency.setTargetAtTime(160 + inf.danger * 70 + (lowAmmo ? 16 : 0), now, .09);
          }
          if (phGain) {
            const lv = inf.gameOver ? 0 : clamp(inf.phalanxLevel ?? 0, 0, 1),
              pn = clamp(inf.phalanxPan ?? .5, 0, 1);
            phGain.gain.setTargetAtTime(Math.max(.0001, lv * .95), now, .02);
            if (phPan.pan) phPan.pan.setTargetAtTime(clamp((pn - .5) * 1.9, -1, 1), now, .03);
          }
          if (stormGain) {
            const sv = inf.gameOver ? 0 : weather;
            stormGain.gain.setTargetAtTime(Math.max(.0001, sv * .2), now, .18);
            if (stormBand) stormBand.frequency.setTargetAtTime(760 + sv * 620, now, .16);
            if (stormPan && stormPan.pan) stormPan.pan.setTargetAtTime(Math.sin(now * .11) * .35, now, .35);
          }
          if (lowAmmo && inf.danger > .6 && now > warnPulse) {
            warnPulse = now + 3.2;
            incoming(.5, .42);
          }
          const urgency = inf.danger > 0.8 ? 0.12 : 0;
          const step = Math.max(.14, .42 - inf.level * .009 - inten * .08 - urgency);
          if (beat === 0) beat = now + .1;
          while (beat < now + .15) {
            beatHit(beat, inten + (inf.danger > 0.8 ? 0.3 : 0), inf.level);
            beat += step;
          }
        };
        return {
          unlock,
          update,
          launch,
          hellRaiser,
          enemyLaunch,
          hit,
          impact,
          city,
          emp,
          wave,
          over,
          incoming,
          phalanx,
          nearMiss,
          thunder,
          setVolume(v) { vol = Math.max(0, Math.min(1, v)); updateMasterGain(); },
          getVolume() { return vol; },
          toggleMute() { muted = !muted; updateMasterGain(); },
          isMuted() { return muted; }
        };
      }
      const audio = mkAudio();

      function resize() {
        S.w = innerWidth;
        S.h = innerHeight;
        canvas.width = S.w;
        canvas.height = S.h;
        ensureRenderBuffers();
        S.groundY = Math.floor(S.h * .79);
        S.horizonY = Math.floor(S.h * .56);
        buildSky();
        buildWeather();
        buildTerrain();
        buildWorld();
      }

      function buildSky() {
        S.starsA = [];
        S.starsB = [];
        S.nebula = [];
        S.aurora = [];
        S.clouds = [];
        S.haze = [];
        const a = Math.floor(S.w * S.h / 17000),
          b = Math.floor(S.w * S.h / 9000);
        for (let i = 0; i < a; i++) S.starsA.push({
          x: Math.random() * S.w,
          y: Math.random() * S.horizonY,
          r: rand(.4, 1.4),
          a: rand(.3, .85),
          s: rand(.35, 1.4),
          p: Math.random() * TAU
        });
        for (let i = 0; i < b; i++) S.starsB.push({
          x: Math.random() * S.w,
          y: Math.random() * (S.horizonY + 80),
          r: rand(.6, 2.3),
          a: rand(.35, 1),
          s: rand(.7, 2.2),
          p: Math.random() * TAU
        });
        for (let i = 0; i < 9; i++) S.nebula.push({
          x: rand(S.w * .05, S.w * .95),
          y: rand(S.h * .05, S.h * .54),
          r: rand(S.w * .11, S.w * .23),
          h1: Math.random() < .5 ? 205 : 242,
          h2: Math.random() < .5 ? 272 : 188,
          a: rand(.06, .16),
          d: rand(.05, .18),
          p: Math.random() * TAU
        });
        for (let i = 0; i < 3; i++) S.aurora.push({
          y: S.horizonY * (.35 + i * .11),
          amp: rand(22, 58),
          th: rand(14, 34),
          sp: rand(.14, .4),
          p: Math.random() * TAU,
          h: Math.random() < .5 ? 166 : 198,
          a: rand(.09, .2)
        });
        for (let i = 0; i < 7; i++) S.clouds.push({
          x: rand(-S.w * .1, S.w * 1.1),
          y: rand(S.h * .1, S.horizonY * .86),
          w: rand(S.w * .16, S.w * .34),
          h: rand(S.h * .06, S.h * .12),
          a: rand(.05, .14),
          sp: rand(8, 24),
          p: Math.random() * TAU
        });
        for (let i = 0; i < 5; i++) S.haze.push({
          y: rand(S.horizonY * .78, S.groundY - 30),
          th: rand(44, 92),
          a: rand(.04, .1),
          sp: rand(.08, .24),
          p: Math.random() * TAU
        });
      }

      function setWaveWeather() {
        const roll = Math.random() + S.level * .055;
        let mode = 'clear';
        if (roll > 1.78) mode = 'storm';
        else if (roll > 1.28) mode = 'ash';
        const base = mode === 'clear' ? .06 : mode === 'ash' ? .3 : .44;
        S.weather.mode = mode;
        S.weather.intensity = clamp(base + S.level * .026 + rand(-.08, .08), .04, .92);
        S.weather.wind = rand(-85, 85) * (.55 + S.weather.intensity * .75);
        S.weather.lightningT = rand(3.2, 6.4);
        S.weather.thunderCd = 0;
        buildWeather();
      }

      function buildWeather() {
        const w = S.weather;
        w.particles = [];
        w.fogBands = [];
        const mode = w.mode || 'clear';
        const inten = clamp(w.intensity || 0, 0, 1);
        const count = mode === 'storm' ? Math.floor(150 + inten * 320) : mode === 'ash' ? Math.floor(90 + inten * 180) : 0;
        for (let i = 0; i < count; i++) {
          const isRain = mode === 'storm';
          w.particles.push({
            x: Math.random() * S.w,
            y: Math.random() * S.h,
            z: rand(.5, 1.4),
            a: rand(.18, .7),
            len: isRain ? rand(12, 34) : rand(1.2, 4.2),
            t: rand(.35, 1.6),
            vx: w.wind * rand(.25, .9),
            vy: isRain ? rand(360, 760) : rand(26, 84),
            hue: mode === 'ash' ? rand(22, 42) : rand(185, 205)
          });
        }
        const fogBands = mode === 'clear' ? 1 : mode === 'ash' ? 4 : 5;
        for (let i = 0; i < fogBands; i++) {
          w.fogBands.push({
            y: rand(S.horizonY - 40, S.groundY + 90),
            th: rand(50, 140),
            a: (mode === 'clear' ? rand(.018, .045) : rand(.03, .15)) * (.5 + inten),
            sp: rand(.02, .16),
            p: Math.random() * TAU
          });
        }
      }

      function buildTerrain() {
        S.mountFar = mountLayer(S.horizonY + 70, S.h * .11, 16, .6);
        S.mountNear = mountLayer(S.horizonY + 130, S.h * .14, 20, 1);
      }

      function mountLayer(base, amp, segs, r) {
        const pts = [];
        const overscan = S.w * .1;
        for (let i = 0; i <= segs; i++) {
          const x = -overscan + (i / segs * (S.w + overscan * 2)),
            w = Math.sin(i / segs * Math.PI * (1.5 + r * .7));
          pts.push({
            x,
            y: base - (w * amp + rand(-amp * .45, amp * .55))
          });
        }
        return pts;
      }

      function buildWorld() {
        const bases = 3,
          cities = 6,
          usable = S.w * .86,
          left = (S.w - usable) / 2,
          cityStep = cities > 1 ? usable / (cities - 1) : 0,
          baseStep = usable / (bases * 2);
        S.bases = [];
        S.cities = [];
        for (let i = 0; i < bases; i++) {
          const x = left + (i * 2 + 1) * baseStep;
          S.bases.push({
            id: `B${i + 1}`,
            x,
            y: S.groundY,
            ammo: 18,
            cool: 0,
            destroyed: false
          });
        }
        for (let i = 0; i < cities; i++) {
          const x = left + i * cityStep,
            w = rand(Math.max(46, cityStep * .34), Math.max(72, cityStep * .5)),
            h = rand(34, 88);
          S.cities.push({
            id: `C${i + 1}`,
            x,
            y: S.groundY,
            w,
            h,
            alive: true,
            profile: cityProfile(w, h),
            ruin: null
          });
        }
        const mid = S.bases[Math.floor(S.bases.length / 2)] ?? {
          x: S.w * .5
        };
        const px = clamp(mid.x + 62, 26, S.w - 26);
        S.phalanx = {
          x: px,
          y: S.groundY,
          ammo: 0,
          maxAmmo: 0,
          cool: 0,
          fireAcc: 0,
          audioT: 0,
          heat: 0,
          fireMix: 0,
          target: null,
          targetKind: null,
          targetDist: 0,
          lockKey: null,
          aimAng: -Math.PI * .5,
          aimX: px,
          aimY: S.groundY - 180,
          aimErr: Math.PI,
          destroyed: false
        };
        S.hellRaiser = {
          x: S.w * .5,
          y: S.groundY + Math.max(18, (S.h - S.groundY) * .22),
          state: 'hidden',
          command: 'idle',
          door: 0,
          lift: 0,
          ammo: 0,
          maxAmmo: 0,
          hp: 0,
          maxHp: 8,
          fireAcc: 0,
          audioT: 0,
          activeT: 0,
          cool: 0,
          destroyed: false
        };
      }

      function cityProfile(w, h) {
        const p = [],
          n = Math.floor(rand(5, 9)),
          slice = w / n;
        for (let i = 0; i < n; i++) {
          const bw = slice * rand(.7, 1.04),
            bh = h * rand(.5, 1),
            roof = Math.random() < .52 ? bh * rand(.08, .2) : 0,
            x0 = i * slice + (slice - bw) * .5,
            cols = Math.max(2, Math.floor(bw / 12)),
            rows = Math.max(2, Math.floor(bh / 16)),
            wins = [],
            step = Math.random() < .58 ? bw * rand(.16, .34) : 0,
            stepH = bh * rand(.22, .36),
            ledge = rand(.08, .2),
            spire = Math.random() < .26 ? bh * rand(.1, .24) : 0;
          for (let r = 0; r < rows; r++)
            for (let c = 0; c < cols; c++) wins.push({
              x: 2 + c * ((bw - 4) / cols) + rand(.35, 1.4),
              y: -bh + 2 + r * ((bh - 6) / rows) + rand(.5, 1.7),
              w: Math.max(2, bw / cols * rand(.24, .46)),
              h: Math.max(2, bh / rows * rand(.24, .42)),
              p: Math.random() * TAU,
              s: rand(1.4, 4.8),
              g: rand(.52, 1)
            });
          p.push({
            x0,
            w: bw,
            h: bh,
            roof,
            wins,
            a: rand(.1, .95),
            ant: Math.random() < .32 ? bh * rand(.08, .18) : 0,
            step,
            stepH,
            ledge,
            spire
          });
        }
        return p;
      }

      function cityRuin(city, impact) {
        const fr = [],
          emb = [];
        for (const b of city.profile) {
          const c = 1 + Math.floor(Math.random() * 2);
          for (let i = 0; i < c; i++) {
            const w = b.w / c * rand(.72, 1.18),
              h = b.h * rand(.25, .45),
              o = b.x0 + rand(0, Math.max(0, b.w - w));
            fr.push({
              x: o + w / 2,
              w,
              h,
              l1: rand(-.45, .45),
              l2: rand(-.4, .4),
              n: rand(.4, .84),
              gp: Math.random() * TAU,
              e: Math.random() < .7,
              t: rand(.15, .95)
            });
          }
        }
        for (let i = 0; i < Math.floor(rand(7, 14)); i++) emb.push({
          x: clamp(impact + rand(-city.w * .4, city.w * .4), 4, city.w - 4),
          y: rand(-28, -6),
          r: rand(1.8, 3.8),
          p: Math.random() * TAU,
          s: rand(2.2, 5.8)
        });
        return {
          fr,
          emb,
          impact,
          scar: city.w * rand(.24, .41),
          gp: Math.random() * TAU
        };
      }

      function resetGame() {
        const dbgEnabled = S.debug?.enabled ?? false;
        S.level = 1;
        S.score = 0;
        S.combo = 0;
        S.maxCombo = 0;
        S.comboTimer = 0;
        S.gameOver = false;
        S.gameOverSfx = false;
        S.intro = false;
        S.time = 0;
        S.danger = 0;
        S.ufo = [];
        S.raiders = [];
        S.demon = null;
        S.enemy = [];
        S.player = [];
        S.expl = [];
        S.sparks = [];
        S.smoke = [];
        S.trails = [];
        S.debris = [];
        S.shock = [];
        S.lightBursts = [];
        S.emp = 1;
        S.empCd = 0;
        S.shake = 0;
        S.flash = 0;
        S.shop = false;
        S.shopTimer = 0;
        S.upgrades = {
          blastScale: 1.0,
          reloadMult: 1.0,
          empScale: 1.0,
          phalanxEff: 1.0
        };
        S.selectedBase = null;
        S.floatingTexts = [];
        S.weather.mode = 'clear';
        S.weather.intensity = .15;
        S.weather.wind = rand(-40, 40);
        S.debug.sessionStartedAt = new Date().toISOString();
        S.debug.currentWave = null;
        S.debug.waveSeq = 0;
        S.debug.waves = {};
        S.debug.sessionDrops = 0;
        S.debug.enabled = dbgEnabled;
        buildWeather();
        buildWorld();
        startWave(2.5);
      }

      function wavePlan(level) {
        const total = 14 + level * 5,
          plan = [];
        let t = 0;
        const w = [{
          v: 'standard',
          w: 58
        }, {
          v: 'fast',
          w: level > 1 ? 20 + level * 1.8 : 6
        }, {
          v: 'zig',
          w: level > 2 ? 12 + level * 1.8 : 0
        }, {
          v: 'stealth',
          w: level > 2 ? 10 + level * 1.6 : 0
        }, {
          v: 'decoy',
          w: level > 2 ? 10 + level * 1.4 : 0
        }, {
          v: 'split',
          w: level > 3 ? 9 + level * 1.45 : 0
        }, {
          v: 'heavy',
          w: level > 4 ? 8 + level * 1.25 : 0
        }, {
          v: 'cruise',
          w: level > 3 ? 8 + level * 1.3 : 0
        }, {
          v: 'carrier',
          w: level > 5 ? 4 + level * .9 : 0
        }, {
          v: 'drone',
          w: level > 4 ? 5 + level * 1.1 : 0
        }];
        for (let i = 0; i < total; i++) {
          const salvo = Math.random() < clamp(.13 + level * .02, .13, .48) ? 2 + (Math.random() < .25 ? 1 : 0) : 1,
            lane = pick([{
              v: -.68,
              w: 1
            }, {
              v: -.35,
              w: 1.2
            }, {
              v: 0,
              w: 1.6
            }, {
              v: .35,
              w: 1.2
            }, {
              v: .68,
              w: 1
            }]);
          for (let s = 0; s < salvo && plan.length < total; s++) plan.push({
            at: t + s * rand(.06, .16),
            v: pick(w),
            lane: lane + rand(-.12, .12)
          });
          t += Math.max(.28, 1.26 - level * .05) + rand(.06, .72);
        }
        return plan.sort((a, b) => a.at - b.at);
      }

      function startWave(delay) {
        S.ufo = [];
        S.raiders = [];
        S.enemy = [];
        S.player = [];
        S.expl = [];
        S.sparks = [];
        S.smoke = [];
        S.trails = [];
        S.debris = [];
        S.shock = [];
        S.lightBursts = [];
        setWaveWeather();
        const waveBaseAmmo = Math.min(155, Math.round(20 + S.level * 2.7 + Math.max(0, S.level - 14) * 1.35));
        for (const b of S.bases) {
          if (b.destroyed && Math.random() < .33) b.destroyed = false;
          b.ammo = b.destroyed ? 0 : waveBaseAmmo;
          b.cool = 0;
        }
        if (S.phalanx) {
          if (S.phalanx.destroyed && Math.random() < .42) S.phalanx.destroyed = false;
          S.phalanx.maxAmmo = S.phalanx.destroyed ? 0 : Math.min(1300, Math.round((620 + S.level * 90) * (1 + (S.upgrades.phalanxEff - 1) * .55)));
          S.phalanx.ammo = S.phalanx.maxAmmo;
          S.phalanx.cool = 0;
          S.phalanx.fireAcc = 0;
          S.phalanx.audioT = 0;
          S.phalanx.heat = 0;
          S.phalanx.fireMix = 0;
          S.phalanx.target = null;
          S.phalanx.targetKind = null;
          S.phalanx.targetDist = 0;
          S.phalanx.lockKey = null;
          S.phalanx.aimAng = -Math.PI * .5;
          S.phalanx.aimX = S.phalanx.x;
          S.phalanx.aimY = S.groundY - 180;
          S.phalanx.aimErr = Math.PI;
        }
        if (S.hellRaiser) {
          const hr = S.hellRaiser;
          if (hr.destroyed && Math.random() < .58) hr.destroyed = false;
          hr.maxAmmo = hr.destroyed ? 0 : Math.min(1100, Math.round(460 + S.level * 70));
          hr.ammo = hr.maxAmmo;
          hr.maxHp = 8 + Math.floor(S.level / 3);
          hr.hp = hr.maxHp;
          hr.state = hr.destroyed ? 'destroyed' : 'hidden';
          hr.command = 'idle';
          hr.door = hr.destroyed ? .5 : 0;
          hr.lift = hr.destroyed ? .45 : 0;
          hr.fireAcc = 0;
          hr.audioT = 0;
          hr.activeT = 0;
          hr.cool = hr.destroyed ? 0 : .95;
        }
        if (S.level > 1) S.emp = clamp(S.emp + 1, 0, S.empMax);
        S.wavePlan = wavePlan(S.level);
        S.wavePause = delay;
        S.waveTime = 0;
        S.spawnI = 0;
        S.ufoQuota = S.level >= 2 ? Math.min(3, 1 + Math.floor((S.level - 2) / 2)) : 0;
        S.nextUfo = delay + rand(5.8, 10.6);
        S.raiderQuota = S.level >= 4 ? Math.min(2 + Math.floor(S.level / 6), 4) : 0;
        S.nextRaider = delay + rand(4.4, 8.2);
        if (S.debug.enabled) debugStartWave(S.level, {
          delay: round3(delay),
          weather: S.weather.mode,
          weatherIntensity: round3(S.weather.intensity),
          plannedSpawns: S.wavePlan.length,
          ufoQuota: S.ufoQuota,
          raiderQuota: S.raiderQuota
        });
        note(`Wave ${S.level} incoming | ${S.weather.mode.toUpperCase()} FRONT`, 2.1);
        audio.wave();
      }

      function chooseTarget(v) {
        const c = [];
        for (const city of S.cities) {
          if (!city.alive) continue;
          const neigh = S.cities.filter(x => x.alive && Math.abs(x.x - city.x) < S.w * .14).length;
          let w = 95 + neigh * 22 + rand(0, 18);
          if (v === 'heavy') w += 44;
          if (v === 'split') w += 26;
          if (v === 'ufoBomb') w += 60;
          if (v === 'carrier') w += 28;
          if (v === 'drone') w += 14;
          if (v === 'hell') w += 64;
          if (v === 'spit') w += 22;
          c.push({
            w,
            v: {
              type: 'city',
              ref: city,
              x: city.x + rand(-city.w * .24, city.w * .24),
              y: S.groundY - city.h
            }
          });
        }
        for (const b of S.bases) {
          if (b.destroyed) continue;
          let w = 72 + b.ammo * 2.6 + rand(0, 16);
          if (v === 'fast') w += 28;
          if (v === 'zig') w += 14;
          if (v === 'ufoBomb') w -= 14;
          if (v === 'cruise') w += 56;
          if (v === 'carrier') w += 18;
          if (v === 'drone') w += 26;
          if (v === 'hell') w += 42;
          if (v === 'spit') w += 14;
          c.push({
            w,
            v: {
              type: 'base',
              ref: b,
              x: b.x,
              y: S.groundY - 14
            }
          });
        }
        if (S.phalanx && !S.phalanx.destroyed) {
          let w = 36 + S.phalanx.ammo * .015 + rand(0, 9);
          if (v === 'fast' || v === 'heavy') w += 12;
          if (v === 'drone') w += 18;
          if (v === 'cruise') w += 16;
          if (v === 'hell') w += 10;
          c.push({
            w,
            v: {
              type: 'phalanx',
              ref: S.phalanx,
              x: S.phalanx.x,
              y: S.groundY - 18
            }
          });
        }
        if (hellRaiserVulnerable()) {
          const hr = S.hellRaiser,
            top = hellRaiserTop(hr);
          let w = 64 + hr.ammo * .03 + rand(0, 16);
          if (v === 'heavy' || v === 'carrier' || v === 'hell') w += 36;
          if (v === 'fast' || v === 'drone') w += 12;
          c.push({
            w,
            v: {
              type: 'hellRaiser',
              ref: hr,
              x: top.x + rand(-10, 10),
              y: top.y + rand(-6, 6)
            }
          });
        }
        return c.length ? pick(c) : null;
      }

      function spawnUfoBomb(u) {
        const t = chooseTarget('ufoBomb');
        if (!t) return;
        const sx = u.x + rand(-20, 20),
          sy = u.y + 8,
          dx = t.x - sx,
          dy = t.y - sy,
          dist = Math.max(130, Math.hypot(dx, dy)),
          sp = vSpeed('ufoBomb'),
          dur = dist / sp;
        S.enemy.push({
          id: S.id++,
          v: 'ufoBomb',
          x: sx,
          y: sy,
          sx,
          sy,
          tx: t.x,
          ty: t.y,
          vx: dx / dur,
          vy: dy / dur,
          dur,
          el: 0,
          sp,
          payload: t,
          trail: [],
          trailT: 0,
          res: vRes('ufoBomb'),
          val: vValue('ufoBomb'),
          reserve: false,
          warn: false,
          near: false,
          splitAt: 0,
          split: false,
          amp: 0,
          fq: 0,
          ph: 0,
          blast: rand(44, 70),
          hp: 1,
          deployed: false,
          deployAt: 0,
          homing: 0
        });
        debugInc('enemySpawn', 'ufoBomb');
        debugInc('enemyTargetType', t.type ?? 'unknown');
        debugRecord('enemy_spawn', {
          id: S.id - 1,
          enemyType: 'ufoBomb',
          source: `ufo:${u.id}`,
          from: {
            x: round3(sx),
            y: round3(sy)
          },
          target: targetSnapshot(t)
        });
        audio.enemyLaunch(clamp(sx / S.w, 0, 1));
      }

      function spawnUfo() {
        const alive = S.cities.filter(c => c.alive);
        if (!alive.length) return false;
        const left = Math.random() < .5,
          baseY = rand(S.horizonY * .62, S.horizonY * .88),
          x = left ? -90 : S.w + 90;

        const isBoss = S.level >= 5 && Math.random() < 0.2 + (S.level * 0.05);
        const vxMult = isBoss ? 0.6 : 1;
        const vx = left ? (rand(58, 96) + S.level * 3) * vxMult : -(rand(58, 96) + S.level * 3) * vxMult;

        S.ufo.push({
          id: S.id++,
          x,
          y: baseY,
          baseY,
          vx,
          cool: rand(1.25, 2.35),
          hp: isBoss ? 6 : 2,
          maxHp: isBoss ? 6 : 2,
          isBoss,
          bobAmp: rand(7, 16) * (isBoss ? 1.5 : 1),
          bobSp: rand(1.4, 2.6) * (isBoss ? 0.6 : 1),
          ph: Math.random() * TAU,
          t: 0,
          autoReserve: 0
        });
        debugInc('enemyVehicleSpawn', isBoss ? 'bossUfo' : 'ufo');
        debugRecord('enemy_vehicle_spawn', {
          vehicle: 'ufo',
          id: S.id - 1,
          boss: isBoss,
          from: {
            x: round3(x),
            y: round3(baseY)
          },
          vx: round3(vx)
        });

        note(isBoss ? 'WARNING: Boss UFO detected' : 'UFO intruder detected', 1.1);
        audio.incoming(.5, isBoss ? 1.2 : .95);
        return true;
      }

      function spawnDroneAt(x, y, targetOverride = null, source = 'drone') {
        const t = targetOverride || chooseTarget('drone');
        if (!t) return;
        const sx = x,
          sy = y,
          dx = t.x - sx,
          dy = t.y - sy,
          dist = Math.max(120, Math.hypot(dx, dy)),
          sp = vSpeed('drone'),
          dur = dist / sp;
        createEnemyProjectile('drone', sx, sy, t, {
          amp: rand(14, 38),
          fq: rand(1.8, 3.2),
          blast: rand(34, 52),
          homing: 0.2,
          source
        });
        audio.enemyLaunch(clamp(sx / S.w, 0, 1));
      }

      function deployCarrierDrones(m) {
        const count = 3 + (Math.random() < .45 ? 1 : 0);
        for (let i = 0; i < count; i++) {
          const t = chooseTarget('drone');
          if (!t) continue;
          spawnDroneAt(m.x + rand(-20, 20), m.y + rand(-8, 10), t, `carrier:${m.id}`);
        }
        m.deployed = true;
        debugRecord('enemy_deploy', {
          enemyType: 'carrier',
          id: m.id,
          deploy: 'drone_swarm'
        });
        note('Carrier deployed drone swarm', .8);
      }

      function createEnemyProjectile(v, sx, sy, t, opt = {}) {
        if (!t) return null;
        const dx = t.x - sx,
          dy = t.y - sy,
          dist = Math.max(100, Math.hypot(dx, dy)),
          sp = vSpeed(v),
          dur = dist / sp;
        const m = {
          id: S.id++,
          v,
          x: sx,
          y: sy,
          sx,
          sy,
          tx: t.x,
          ty: t.y,
          vx: dx / dur,
          vy: dy / dur,
          dur,
          el: 0,
          sp,
          payload: t,
          trail: [],
          trailT: 0,
          res: vRes(v),
          val: vValue(v),
          reserve: false,
          reserveUntil: 0,
          autoAttempts: 0,
          autoLastAssignAt: -999,
          autoPredictedInterceptAt: 0,
          warn: false,
          near: false,
          splitAt: v === 'split' ? rand(.4, .63) : 0,
          split: false,
          amp: opt.amp ?? (v === 'zig' ? rand(40, 95) : v === 'drone' ? rand(16, 36) : v === 'cruise' ? rand(6, 18) : v === 'spit' ? rand(8, 20) : v === 'hell' ? rand(18, 34) : 0),
          fq: opt.fq ?? (v === 'zig' ? rand(1.1, 2) : v === 'drone' ? rand(2.1, 3.8) : v === 'cruise' ? rand(.7, 1.3) : v === 'spit' ? rand(1.1, 2.1) : v === 'hell' ? rand(1.2, 2.4) : 0),
          ph: (v === 'zig' || v === 'drone' || v === 'cruise' || v === 'spit' || v === 'hell') ? Math.random() * TAU : 0,
          blast: opt.blast ?? (v === 'heavy' ? rand(120, 170) : v === 'carrier' ? rand(118, 150) : v === 'drone' ? rand(34, 52) : v === 'cruise' ? rand(70, 102) : v === 'spit' ? rand(44, 72) : v === 'hell' ? rand(108, 152) : rand(56, 90)),
          hp: opt.hp ?? (v === 'carrier' ? 3 : 1),
          deployed: false,
          deployAt: v === 'carrier' ? rand(.35, .62) : 0,
          homing: opt.homing ?? (v === 'cruise' ? rand(.62, .95) : v === 'drone' ? rand(.25, .5) : v === 'hell' ? rand(.35, .6) : 0),
          src: opt.source ?? 'wave'
        };
        S.enemy.push(m);
        debugInc('enemySpawn', v);
        debugInc('enemyTargetType', t.type ?? 'unknown');
        debugRecord('enemy_spawn', {
          id: m.id,
          enemyType: v,
          source: m.src,
          from: {
            x: round3(sx),
            y: round3(sy)
          },
          to: {
            x: round3(m.tx),
            y: round3(m.ty)
          },
          target: targetSnapshot(t)
        });
        return m;
      }

      function spawnRaiderSpit(r, burst = 4) {
        for (let i = 0; i < burst; i++) {
          const t = chooseTarget('spit');
          if (!t) continue;
          createEnemyProjectile('spit', r.x + rand(-20, 20), r.y + 10, t, {
            blast: rand(46, 78),
            amp: rand(10, 28),
            fq: rand(1.2, 2.4),
            source: `raider:${r.id}`
          });
        }
      }

      function spawnRaider() {
        const left = Math.random() < .5,
          x = left ? -95 : S.w + 95,
          y = rand(S.horizonY * .14, S.horizonY * .34),
          dir = left ? 1 : -1;
        S.raiders.push({
          id: S.id++,
          x,
          y,
          vx: dir * rand(150, 210),
          turnT: rand(.7, 1.4),
          spitT: rand(.65, 1.25),
          hp: 5,
          maxHp: 5,
          ang: 0,
          ph: Math.random() * TAU
        });
        debugInc('enemyVehicleSpawn', 'raider');
        debugRecord('enemy_vehicle_spawn', {
          vehicle: 'raider',
          id: S.id - 1,
          from: {
            x: round3(x),
            y: round3(y)
          },
          vx: round3(dir * Math.abs(S.raiders[S.raiders.length - 1].vx))
        });
        note('Stratospheric Raider detected', .95);
        audio.incoming(clamp((x < 0 ? 0 : 1), 0, 1), 1.05);
        return true;
      }

      function summonDaemon() {
        if (S.demon) return;
        S.demon = {
          x: S.w * .5,
          y: S.horizonY * .22,
          vx: 160,
          life: 18,
          cool: .7,
          havocT: .9,
          ph: Math.random() * TAU
        };
        debugInc('enemyVehicleSpawn', 'daemon');
        debugRecord('enemy_vehicle_spawn', {
          vehicle: 'daemon',
          id: 'daemon',
          from: {
            x: round3(S.w * .5),
            y: round3(S.horizonY * .22)
          }
        });
        note('EASTER EGG: DAEMON UNLEASHED', 1.8);
        S.flash = Math.max(S.flash, .28);
        S.shake = Math.max(S.shake, 11);
        if (audio.thunder) audio.thunder(.5, 1.0);
      }

      function spawnEnemy(e) {
        const t = chooseTarget(e.v);
        if (!t) {
          S.gameOver = true;
          return;
        }
        const cruise = e.v === 'cruise';
        const carrier = e.v === 'carrier';
        const sx = cruise ? (Math.random() < .5 ? -70 : S.w + 70) : clamp(S.w * .5 + e.lane * S.w * .44 + rand(-140, 140), 14, S.w - 14);
        const sy = cruise ? rand(S.horizonY * .66, S.groundY * .52) : carrier ? rand(-220, -120) : rand(-160, -40);
        createEnemyProjectile(e.v, sx, sy, t, {
          source: 'wave_plan'
        });
        audio.enemyLaunch(sx / S.w);
      }

      function launchPlayer(tx, ty, base, opt = {}) {
        if (S.gameOver || S.intro || S.shop) return false;
        let c = base;
        if (!c) {
          if (S.selectedBase !== null && S.bases[S.selectedBase] && !S.bases[S.selectedBase].destroyed && S.bases[S.selectedBase].ammo > 0 && S.bases[S.selectedBase].cool <= 0) {
            c = S.bases[S.selectedBase];
          } else {
            const live = S.bases.filter(b => !b.destroyed && b.ammo > 0);
            if (!live.length) return false;
            c = live.reduce((p, n) => Math.abs(n.x - tx) < Math.abs(p.x - tx) ? n : p, live[0]);
          }
        }
        if (c.destroyed || c.ammo <= 0 || c.cool > 0) {
          if (!opt.fast) S.shake = Math.max(S.shake, 2);
          return false;
        }
        const y = Math.min(ty, opt.allowGround ? S.groundY - 16 : S.groundY - 56),
          dx = tx - c.x,
          dy = y - c.y,
          dist = Math.max(90, Math.hypot(dx, dy)),
          dur = dist / interceptorSpeed(opt.fast ? 1.06 : 1);
        c.ammo--;
        const reloadMult = S.upgrades?.reloadMult ?? 1.0;
        const lvlReload = 1 + Math.min(1.9, S.level * .03);
        c.cool = (opt.fast ? .14 : .24) / (Math.max(.4, reloadMult) * lvlReload);
        S.player.push({
          id: S.id++,
          x: c.x,
          y: c.y,
          sx: c.x,
          sy: c.y,
          tx,
          ty: y,
          vx: dx / dur,
          vy: dy / dur,
          dur,
          el: 0,
          trail: [],
          trailT: 0,
          blast: (opt.blast ?? 102) * (S.upgrades ? S.upgrades.blastScale : 1.0),
          det: S.time + dur,
          emp: false
        });
        debugInc('defenseShots', opt.auto ? 'auto' : 'manual');
        debugRecord('defense_fire', {
          defense: 'base',
          mode: opt.auto ? 'auto' : 'manual',
          baseId: c.id,
          shotId: S.id - 1,
          from: {
            x: round3(c.x),
            y: round3(c.y)
          },
          to: {
            x: round3(tx),
            y: round3(y)
          },
          eta: round3(dur),
          ammoAfter: c.ammo,
          cooldown: round3(c.cool)
        });
        audio.launch(c.x / S.w);
        return true;
      }

      function useEMP() {
        if (S.intro || S.gameOver || S.emp <= 0 || S.empCd > 0) return false;
        S.emp--;
        S.empCd = 13;
        spawnExpl(S.mouse.x, S.mouse.y, {
          player: true,
          r: 228 * (S.upgrades?.empScale ?? 1.0),
          life: 1.45,
          sh: .42,
          emp: true,
          flash: .32
        });
        S.shake = Math.max(S.shake, 20);
        S.flash = Math.max(S.flash, .32);
        debugRecord('defense_emp', {
          x: round3(S.mouse.x),
          y: round3(S.mouse.y),
          empAfter: S.emp,
          cooldown: round3(S.empCd)
        });
        note('EMP pulse deployed', 1.1);
        audio.emp();
        return true;
      }

      function splitMissile(m) {
        m.split = true;
        debugRecord('enemy_split', {
          id: m.id,
          enemyType: m.v,
          at: {
            x: round3(m.x),
            y: round3(m.y)
          }
        });
        spawnExpl(m.x, m.y, {
          player: false,
          r: 42,
          life: .62,
          sh: .28,
          flash: .08,
          noShake: true
        });
        const count = 2 + (Math.random() < .35 ? 1 : 0);
        for (let i = 0; i < count; i++) {
          const t = chooseTarget('shard');
          if (!t) continue;
          const tx = clamp(lerp(t.x, m.tx + rand(-150, 150), .42), 18, S.w - 18),
            ty = t.y,
            dx = tx - m.x,
            dy = ty - m.y,
            dist = Math.max(120, Math.hypot(dx, dy)),
            sp = vSpeed('shard'),
            dur = dist / sp;
          S.enemy.push({
            id: S.id++,
            v: 'shard',
            x: m.x,
            y: m.y,
            sx: m.x,
            sy: m.y,
            tx,
            ty,
            vx: dx / dur,
            vy: dy / dur,
            dur,
            el: 0,
            sp,
            payload: t,
            trail: [],
            trailT: 0,
            res: vRes('shard'),
            val: vValue('shard'),
            reserve: false,
            reserveUntil: 0,
            autoAttempts: 0,
            autoLastAssignAt: -999,
            autoPredictedInterceptAt: 0,
            warn: false,
            near: false,
            splitAt: 0,
            split: true,
            amp: rand(14, 34),
            fq: rand(1.2, 2.4),
            ph: Math.random() * TAU,
            blast: rand(40, 64),
            hp: 1,
            deployed: false,
            deployAt: 0,
            homing: 0
          });
        }
      }

      function spawnShock(x, y, o = {}) {
        S.shock.push({
          x,
          y,
          r: 8,
          mr: o.mr ?? 140,
          life: o.life ?? .62,
          el: 0,
          emp: !!o.emp,
          alpha: o.alpha ?? .5
        });
      }

      function spawnDebris(x, y, n, heat = 1) {
        for (let i = 0; i < n; i++) {
          const a = rand(-Math.PI * .95, -Math.PI * .05),
            sp = rand(90, 320) * heat;
          S.debris.push({
            x: x + rand(-7, 7),
            y: y + rand(-5, 5),
            vx: Math.cos(a) * sp + rand(-22, 22),
            vy: Math.sin(a) * sp - rand(10, 120),
            rot: rand(0, TAU),
            vr: rand(-7, 7),
            w: rand(2.2, 6.8),
            h: rand(1.3, 4.2),
            life: rand(.8, 1.9),
            el: 0,
            hot: rand(.45, .95),
            ember: Math.random() < .55
          });
        }
      }

      function spawnExpl(x, y, o) {
        const mr = o.r ?? 92,
          heavy = !!o.heavy || (!o.player && !o.emp && mr > 120);
        S.expl.push({
          x,
          y,
          r: 0,
          mr,
          life: o.life ?? 1.3,
          sh: o.sh ?? .36,
          el: 0,
          player: !!o.player,
          emp: !!o.emp,
          t0: S.time
        });
        if (!o.noShake) S.shake = Math.max(S.shake, o.emp ? 19 : o.player ? 7 : heavy ? 14 : 11);
        if (o.flash) S.flash = Math.max(S.flash, o.flash);
        S.lightBursts.push({
          x,
          y,
          r: mr * (o.emp ? .9 : .7),
          life: o.emp ? .72 : .5,
          el: 0,
          warm: !o.player
        });
        if (o.emp || heavy || mr > 92) spawnShock(x, y, {
          mr: mr * (o.emp ? 1.28 : .98),
          life: o.emp ? .86 : .6,
          emp: !!o.emp,
          alpha: o.emp ? .66 : .4
        });
        if (heavy || o.emp) spawnDebris(x, y, Math.floor((o.emp ? 22 : 16) + mr * .08), o.emp ? 1.2 : 1.0);
        else if (!o.player) spawnDebris(x, y, Math.floor(7 + mr * .03), .8);
        if (o.player && !o.emp) audio.hit(x / S.w, .6);
        else if (!o.player) audio.impact(x / S.w, heavy);
        spawnSparks(x, y, !!o.player, !!o.emp, clamp(mr / 100, .9, 1.9));
      }

      function spawnSparks(x, y, player, emp, m = 1) {
        const n = Math.floor((emp ? 46 : player ? 18 : 24) * m);
        for (let i = 0; i < n; i++) {
          const a = Math.random() * TAU,
            s = (emp ? rand(120, 440) : rand(100, 280)) * Math.max(.8, m * .9);
          S.sparks.push({
            x,
            y,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s - rand(0, 70),
            life: emp ? rand(.65, 1.2) : rand(.45, .95),
            el: 0,
            player,
            emp,
            size: emp ? rand(1.6, 3.2) : rand(1.3, 2.6)
          });
        }
      }

      function spawnSmoke(x, y, n, k = 1) {
        for (let i = 0; i < n; i++) S.smoke.push({
          x: x + rand(-34, 34),
          y: y + rand(-18, 6),
          br: rand(11, 26) * k,
          dr: rand(-26, 26),
          rise: rand(18, 42),
          life: rand(2.2, 4.6),
          el: 0,
          a: rand(.16, .35)
        });
      }

      function spawnTrail(x, y, en, v, vx = 0, vy = 0) {
        S.trails.push({
          x,
          y,
          vx: vx * .08 + rand(-16, 16),
          vy: vy * .08 + (en ? rand(18, 38) : rand(8, 26)),
          life: en ? rand(.28, .55) : rand(.2, .42),
          el: 0,
          en,
          v,
          size: en ? rand(1.2, 2.5) : rand(1.1, 2.1),
          dx: vx,
          dy: vy
        });
      }

      function spawnPhalanxTracer(x, y, tx, ty) {
        const a = Math.atan2(ty - y, tx - x) + rand(-.035, .035),
          sp = rand(980, 1320),
          vx = Math.cos(a) * sp,
          vy = Math.sin(a) * sp;
        S.trails.push({
          x,
          y,
          vx,
          vy,
          life: rand(.07, .14),
          el: 0,
          en: false,
          v: 'phalanx',
          size: rand(.85, 1.4),
          dx: vx,
          dy: vy
        });
      }

      function killCity(city, x, y) {
        city.alive = false;
        const hit = clamp(x - (city.x - city.w * .5), 0, city.w);
        city.ruin = cityRuin(city, hit);
        spawnExpl(x, y, {
          player: false,
          r: rand(74, 120),
          life: 1.08,
          sh: .28,
          flash: .22
        });
        spawnSmoke(x, y - 8, 14, 1.2);
        S.shake = Math.max(S.shake, 14);
        S.flash = Math.max(S.flash, .18);
        debugInc('assetsLost', 'cities');
        debugRecord('asset_destroyed', {
          asset: 'city',
          id: city.id,
          at: {
            x: round3(x),
            y: round3(y)
          }
        });
        audio.city(city.x / S.w);
        note('City destroyed', .95);
      }

      function destroyTarget(payload, x, y, blast) {
        if (!payload) return;
        if (payload.type === 'city') {
          if (payload.ref.alive) killCity(payload.ref, x, y);
        } else if (payload.type === 'base') {
          if (!payload.ref.destroyed) {
            payload.ref.destroyed = true;
            payload.ref.ammo = 0;
            debugInc('assetsLost', 'bases');
            debugRecord('asset_destroyed', {
              asset: 'base',
              id: payload.ref.id,
              at: {
                x: round3(payload.ref.x),
                y: round3(payload.ref.y)
              }
            });
            spawnExpl(payload.ref.x, payload.ref.y - 4, {
              player: false,
              r: 84,
              life: 1.05,
              sh: .3,
              flash: .18
            });
          }
        } else if (payload.type === 'phalanx') {
          if (S.phalanx && !S.phalanx.destroyed) {
            S.phalanx.destroyed = true;
            S.phalanx.ammo = 0;
            debugInc('assetsLost', 'phalanx');
            debugRecord('asset_destroyed', {
              asset: 'phalanx',
              id: 'PHALANX',
              at: {
                x: round3(S.phalanx.x),
                y: round3(S.phalanx.y)
              }
            });
            spawnExpl(S.phalanx.x, S.phalanx.y - 6, {
              player: false,
              r: 88,
              life: 1.05,
              sh: .28,
              flash: .2
            });
            note('Phalanx destroyed', 1.1);
          }
        } else if (payload.type === 'hellRaiser') {
          damageHellRaiser(1.9 + blast * .008, x, y);
        }
        if (blast > 100) {
          for (const c of S.cities)
            if (c.alive && Math.abs(c.x - x) <= blast * .75) killCity(c, c.x, S.groundY - c.h * .35);
          for (const b of S.bases)
            if (!b.destroyed && Math.abs(b.x - x) <= blast * .68) {
              b.destroyed = true;
              b.ammo = 0;
              debugInc('assetsLost', 'bases');
              debugRecord('asset_destroyed', {
                asset: 'base',
                id: b.id,
                at: {
                  x: round3(b.x),
                  y: round3(b.y)
                },
                source: 'splash'
              });
              spawnExpl(b.x, b.y - 8, {
                player: false,
                r: 78,
                life: .95,
                sh: .3,
                flash: .12,
                noShake: true
              });
            }
          if (S.phalanx && !S.phalanx.destroyed && Math.abs(S.phalanx.x - x) <= blast * .64) {
            S.phalanx.destroyed = true;
            S.phalanx.ammo = 0;
            debugInc('assetsLost', 'phalanx');
            debugRecord('asset_destroyed', {
              asset: 'phalanx',
              id: 'PHALANX',
              at: {
                x: round3(S.phalanx.x),
                y: round3(S.phalanx.y)
              },
              source: 'splash'
            });
            spawnExpl(S.phalanx.x, S.phalanx.y - 8, {
              player: false,
              r: 82,
              life: .96,
              sh: .3,
              flash: .14,
              noShake: true
            });
          }
          splashHellRaiser(x, y, blast, .72);
        }
      }

      function explRadius(el, mr, sh, life) {
        if (!isFinite(el) || el < 0 || el > life) return 0;
        const p = life > 0 ? el / life : 1;
        if (p < sh) return mr * easeOut(p / Math.max(.0001, sh));
        const q = (p - sh) / Math.max(.0001, 1 - sh);
        return mr * Math.max(0, 1 - easeIn(q));
      }
      const mSpawn = m => S.time - m.el;
      const mImpact = m => mSpawn(m) + m.dur;

      function mPos(m, tAbs) {
        const local = clamp(tAbs - mSpawn(m), 0, m.dur),
          p = m.dur > 0 ? local / m.dur : 1;
        let x = m.sx + m.vx * local,
          y = m.sy + m.vy * local;
        if (m.amp > 0) x += Math.sin(p * m.fq * TAU + m.ph) * m.amp * (1 - p * .5);
        if (m.v === 'heavy') x += Math.sin(p * TAU * .6 + m.id) * 7;
        if (m.v === 'cruise') y += Math.sin(p * TAU * 1.2 + m.ph) * 18 * (1 - p * .32);
        if (m.v === 'drone') {
          x += Math.sin(p * TAU * 3.4 + m.ph) * 12 * (1 - p * .16);
          y += Math.cos(p * TAU * 2.7 + m.ph * .8) * 9 * (1 - p * .22);
        }
        const wi = clamp(S.weather?.intensity ?? 0, 0, 1);
        if (wi > .12 && m.v !== 'heavy') {
          const driftMul = m.v === 'ufoBomb' ? .62 : m.v === 'fast' ? .92 : .8,
            wind = (S.weather?.wind ?? 0) * .0042;
          x += Math.sin((tAbs * (.95 + wi * .42)) + m.id * .37) * wi * 16 * driftMul;
          x += wind * local * driftMul;
        }
        return {
          x,
          y
        };
      }

      function mVel(m, tAbs) {
        const local = clamp(tAbs - mSpawn(m), 0, m.dur),
          p = m.dur > 0 ? local / m.dur : 1;
        let vx = m.vx,
          vy = m.vy;
        if (m.amp > 0 && m.dur > 0) {
          const k = m.fq * TAU / m.dur,
            ph = p * m.fq * TAU + m.ph,
            as = (1 - p * .5),
            das = -.5 / m.dur;
          vx += Math.cos(ph) * m.amp * as * k + Math.sin(ph) * m.amp * das;
        }
        if (m.v === 'heavy' && m.dur > 0) vx += Math.cos(p * TAU * .6 + m.id) * (TAU * .6 / m.dur) * 7;
        if (m.v === 'cruise' && m.dur > 0) {
          const k = TAU * 1.2 / m.dur;
          vx += 0;
          vy += Math.cos(p * TAU * 1.2 + m.ph) * 18 * (1 - p * .32) * k + Math.sin(p * TAU * 1.2 + m.ph) * (-(.32 / m.dur) * 18);
        }
        if (m.v === 'drone' && m.dur > 0) {
          const kx = TAU * 3.4 / m.dur,
            ky = TAU * 2.7 / m.dur,
            phx = p * TAU * 3.4 + m.ph,
            phy = p * TAU * 2.7 + m.ph * .8;
          vx += Math.cos(phx) * 12 * (1 - p * .16) * kx + Math.sin(phx) * (-(.16 / m.dur) * 12);
          vy += -Math.sin(phy) * 9 * (1 - p * .22) * ky + Math.cos(phy) * (-(.22 / m.dur) * 9);
        }
        const wi = clamp(S.weather?.intensity ?? 0, 0, 1);
        if (wi > .12 && m.v !== 'heavy') {
          const driftMul = m.v === 'ufoBomb' ? .62 : m.v === 'fast' ? .92 : .8,
            k = (.95 + wi * .42),
            wind = (S.weather?.wind ?? 0) * .0042;
          vx += Math.cos((tAbs * k) + m.id * .37) * wi * 16 * driftMul * k + wind * driftMul;
        }
        return {
          vx,
          vy
        };
      }

      function coverage(now) {
        const c = [];
        for (const e of S.expl) {
          if (!e.player) continue;
          const st = e.t0,
            life = e.life;
          c.push({
            x: e.x,
            y: e.y,
            st,
            en: st + life,
            rAt: t => explRadius(t - st, e.mr, e.sh, life)
          });
        }
        for (const m of S.player) {
          if (m.hr) continue;
          const st = m.det,
            life = 1.3;
          c.push({
            x: m.tx,
            y: m.ty,
            st,
            en: st + life,
            rAt: t => explRadius(t - st, m.blast, .36, life)
          });
        }
        return c;
      }

      function enemyCovered(m, cov, now) {
        const hit = mImpact(m);
        for (const c of cov) {
          const a = Math.max(now, c.st),
            b = Math.min(hit, c.en);
          if (b <= a) continue;
          const dur = b - a,
            steps = Math.max(4, Math.ceil(dur / .1));
          for (let i = 0; i <= steps; i++) {
            const t = a + dur * i / steps,
              pos = mPos(m, t),
              r = c.rAt(t) * (1 - m.res * .3);
            if (r <= 5) continue;
            const dx = pos.x - c.x,
              dy = pos.y - c.y;
            if (dx * dx + dy * dy <= r * r) return true;
          }
        }
        return false;
      }

      function hitConflict(intr, cov, now) {
        const t = now + intr.t;
        for (const c of cov) {
          if (t < c.st || t > c.en) continue;
          const r = c.rAt(t),
            dx = intr.x - c.x,
            dy = intr.y - c.y;
          if (dx * dx + dy * dy <= (r - 8) * (r - 8)) return true;
        }
        return false;
      }
      const tImpact = m => Math.max(0, m.dur - m.el);

      function threat(m) {
        const ti = tImpact(m);
        let tv = 70;
        if (m.payload?.type === 'city' && m.payload.ref?.alive) tv = 120;
        if (m.payload?.type === 'base' && !m.payload.ref?.destroyed) tv = 100 + m.payload.ref.ammo * 1.2;
        if (m.payload?.type === 'hellRaiser' && hellRaiserVulnerable()) tv = 132;
        if (m.payload?.type === 'phalanx' && S.phalanx && !S.phalanx.destroyed) tv = 172;
        const mul = m.v === 'heavy' ? 1.65 : m.v === 'split' ? 1.45 : m.v === 'zig' ? 1.35 : m.v === 'fast' ? 1.2 : m.v === 'ufoBomb' ? 1.42 : m.v === 'cruise' ? 1.58 : m.v === 'carrier' ? 1.9 : m.v === 'drone' ? 1.28 : m.v === 'spit' ? 1.24 : m.v === 'hell' ? 1.74 : 1;
        const hpBonus = Math.max(0, (m.hp ?? 1) - 1) * 42;
        return tv * mul + 128 / (ti + .75) + m.sp * .18 + hpBonus;
      }

      function threatUfo(u) {
        const c = S.cities.filter(x => x.alive);
        let near = 0;
        for (const city of c) {
          const d = Math.abs(city.x - u.x);
          if (d < S.w * .16) near = Math.max(near, 1 - d / (S.w * .16));
        }
        return 168 + near * 110 + Math.abs(u.vx) * .42 + (3 - u.hp) * 34;
      }

      function phalanxAcquireTarget(p, lockRange, fireRange) {
        const originY = p.y - 52;
        let best = null,
          terminalBest = null;
        const consider = (k, o, x, y, baseScore, eta = null, meta = null) => {
          const dx = x - p.x,
            dy = y - originY,
            dist = Math.hypot(dx, dy);
          if (dist > lockRange || y > S.groundY + 8) return;
          const imminence = eta === null ? 0 : 180 / (eta + .35),
            rangeBias = dist <= fireRange ? 54 : 0,
            boost = meta?.boost ?? 0,
            score = baseScore + imminence + rangeBias - dist * .14 + boost;
          const entry = {
            k,
            o,
            x,
            y,
            dist,
            score,
            eta,
            payloadType: meta?.payloadType ?? null,
            terminal: !!meta?.terminal
          };
          if (!best || score > best.score) {
            best = entry;
          }
          if (entry.terminal) {
            if (!terminalBest) terminalBest = entry;
            else if ((entry.eta ?? 99) < (terminalBest.eta ?? 99) - .04) terminalBest = entry;
            else if (entry.score > terminalBest.score) terminalBest = entry;
          }
        };
        for (const m of S.enemy) {
          if (m.y > S.groundY - 4) continue;
          const payloadType = m.payload?.type ?? null,
            eta = tImpact(m);
          let base = threat(m) + (payloadType === 'city' ? 62 : 0) + (payloadType === 'base' ? 24 : 0) + (payloadType === 'hellRaiser' ? 32 : 0) + (payloadType === 'phalanx' && S.phalanx && !S.phalanx.destroyed ? 240 : 0) + (m.v === 'ufoBomb' ? 42 : 0);
          if (payloadType === 'phalanx' && S.phalanx && !S.phalanx.destroyed && eta <= 2.2) base += 170;
          const terminal = payloadType === 'phalanx' && S.phalanx && !S.phalanx.destroyed && eta <= 1.35,
            boost = terminal ? 680 + (1.35 - eta) * 220 : 0;
          consider('enemy', m, m.x, m.y, base, eta, {
            payloadType,
            terminal,
            boost
          });
        }
        for (const u of S.ufo) {
          const base = threatUfo(u) + (u.isBoss ? 80 : 54);
          consider('ufo', u, u.x, u.y, base, null);
        }
        for (const r of S.raiders) {
          const hpLoss = 1 - clamp(r.hp / r.maxHp, 0, 1),
            base = 250 + hpLoss * 110;
          consider('raider', r, r.x, r.y, base, null);
        }
        if (S.demon) {
          consider('demon', S.demon, S.demon.x, S.demon.y, 320, null);
        }
        if (terminalBest) return terminalBest;
        return best;
      }

      function phalanxLeadSec(t) {
        if (!t || !t.o) return .045;
        if (t.k === 'enemy') {
          const vx = t.o.cv ?? t.o.vx ?? 0,
            vy = t.o.cy ?? t.o.vy ?? 0,
            speed = Math.hypot(vx, vy),
            dist = t.dist ?? Math.hypot((t.o.x ?? 0) - (S.phalanx?.x ?? 0), (t.o.y ?? 0) - ((S.phalanx?.y ?? 0) - 52)),
            lead = .02 + dist / 9200 + speed / 18000;
          return clamp(lead, .024, .082);
        }
        if (t.k === 'ufo') return .07;
        if (t.k === 'raider') return .064;
        if (t.k === 'demon') return .06;
        return .05;
      }

      function phalanxTargetPoint(t, lead = .06) {
        if (!t || !t.o) return null;
        const o = t.o;
        if (t.k === 'enemy') return {
          x: o.x + (o.cv ?? o.vx ?? 0) * lead,
          y: o.y + (o.cy ?? o.vy ?? 0) * lead
        };
        if (t.k === 'ufo') return {
          x: o.x + (o.vx ?? 0) * lead,
          y: o.baseY + Math.sin((S.time + lead) * o.bobSp + o.ph) * o.bobAmp
        };
        if (t.k === 'raider') return {
          x: o.x + (o.vx ?? 0) * lead,
          y: o.y + Math.sin((S.time + lead) * 2.7 + o.ph) * 9
        };
        return {
          x: o.x + (o.vx ?? 0) * lead,
          y: o.y
        };
      }

      function intercept(base, m, speed = interceptorSpeed(1.06)) {
        const rem = tImpact(m);
        if (rem <= .05) return null;
        let best = null;
        for (let t = .1; t < rem; t += .045) {
          const pos = mPos(m, S.time + t);
          if (pos.y >= S.groundY - 10 || pos.x < -40 || pos.x > S.w + 40) continue;
          const travel = Math.hypot(pos.x - base.x, pos.y - base.y) / speed,
            err = Math.abs(travel - t);
          if (err > .1) continue;
          const q = err * 8 + t * .07;
          if (!best || q < best.q) best = {
            x: pos.x,
            y: pos.y,
            t,
            q
          };
        }
        return best;
      }

      function interceptUfo(base, u, speed = interceptorSpeed(1.06)) {
        let best = null;
        for (let t = .14; t < 3.4; t += .055) {
          const x = u.x + u.vx * t,
            y = u.baseY + Math.sin((S.time + t) * u.bobSp + u.ph) * u.bobAmp;
          if (x < 16 || x > S.w - 16 || y < 24 || y > S.groundY - 84) continue;
          const travel = Math.hypot(x - base.x, y - base.y) / speed,
            err = Math.abs(travel - t);
          if (err > .13) continue;
          const q = err * 8 + t * .12 + Math.abs(base.x - x) * .0007;
          if (!best || q < best.q) best = {
            x,
            y,
            t,
            q
          };
        }
        return best;
      }

      function runAuto() {
        const bases = S.bases.filter(b => !b.destroyed && b.ammo > 0 && b.cool <= 0);
        if (!bases.length) return;
        const now = S.time,
          autoSpeed = interceptorSpeed(1.08),
          maxShotsBudget = Math.min(10, 3 + Math.floor(Math.max(0, S.level - 1) / 10)),
          cov = coverage(now),
          en = S.enemy.slice(),
          ufo = S.ufo.filter(u => (u.autoReserve ?? 0) <= now);
        const scan = {
          enemy: {
            covered: 0,
            noIntercept: 0,
            late: 0,
            conflict: 0,
            reserve: 0,
            retry: 0
          },
          ufo: {
            noIntercept: 0,
            conflict: 0
          }
        };
        en.sort((a, b) => threat(b) - threat(a));
        ufo.sort((a, b) => threatUfo(b) - threatUfo(a));
        let shots = 0,
          reserveForUfo = ufo.length ? 1 : 0,
          enemyBudget = Math.max(1, maxShotsBudget - reserveForUfo);
        const wave = S.debug.enabled ? debugEnsureWave() : null;
        if (wave) wave.stats.autoScan.cycles++;
        while (bases.length && en.length && shots < enemyBudget) {
          let best = null,
            ei = -1,
            bi = -1;
          for (let i = 0; i < en.length; i++) {
            const m = en[i];
            const etaImpact = tImpact(m),
              payloadType = m.payload?.type ?? 'unknown',
              cityTarget = payloadType === 'city',
              retryEligible = cityTarget && (m.autoAttempts ?? 0) > 0 && etaImpact <= 1.55,
              terminalCity = cityTarget && etaImpact <= 1.2,
              reserveUntil = m.reserveUntil ?? 0,
              reserveActive = reserveUntil > now || (m.reserve === true && reserveUntil <= 0),
              reserveFresh = (now - (m.autoLastAssignAt ?? -999)) < .2;
            if (reserveActive && !(retryEligible || terminalCity) || (reserveActive && reserveFresh)) {
              scan.enemy.reserve++;
              continue;
            }
            if (retryEligible || terminalCity) scan.enemy.retry++;
            const covered = enemyCovered(m, cov, now);
            if (covered && !(retryEligible || terminalCity)) {
              scan.enemy.covered++;
              continue;
            }
            for (let j = 0; j < bases.length; j++) {
              const b = bases[j],
                intr = intercept(b, m, autoSpeed);
              if (!intr) {
                scan.enemy.noIntercept++;
                continue;
              }
              if (intr.t > tImpact(m)) {
                scan.enemy.late++;
                continue;
              }
              if (hitConflict(intr, cov, now)) {
                scan.enemy.conflict++;
                continue;
              }
              let s = threat(m) - intr.t * 42 - Math.abs(b.x - intr.x) * .045;
              if (cityTarget) s += 58;
              if (m.v === 'fast' || m.v === 'stealth') s += 36;
              if (retryEligible) s += 145;
              if (terminalCity) s += 260;
              if (!best || s > best.s) {
                best = {
                  b,
                  m,
                  intr,
                  s,
                  payloadType,
                  etaImpact,
                  retryEligible,
                  terminalCity
                };
                ei = i;
                bi = j;
              }
            }
          }
          if (!best) break;
          const fired = launchPlayer(best.intr.x, best.intr.y, best.b, {
            allowGround: true,
            fast: true,
            auto: true
          });
          if (fired) {
            const attempt = (best.m.autoAttempts ?? 0) + 1,
              reserveHold = clamp(best.intr.t * .9 + .24, .3, 1.28);
            best.m.autoAttempts = attempt;
            best.m.autoLastAssignAt = now;
            best.m.autoPredictedInterceptAt = now + best.intr.t;
            best.m.reserveUntil = now + reserveHold;
            best.m.reserve = false;
            debugRecord('auto_assignment', {
              baseId: best.b.id,
              targetType: 'enemy',
              targetId: best.m.id,
              enemyType: best.m.v,
              payloadType: best.payloadType,
              cityTarget: best.payloadType === 'city',
              attempt,
              retry: attempt > 1,
              terminalPriority: !!best.terminalCity,
              timeToImpact: round3(best.etaImpact),
              intercept: {
                x: round3(best.intr.x),
                y: round3(best.intr.y),
                t: round3(best.intr.t)
              },
              predictedInterceptAt: round3(best.m.autoPredictedInterceptAt),
              reserveUntil: round3(best.m.reserveUntil),
              score: round3(best.s)
            });
            shots++;
            const m = S.player[S.player.length - 1];
            if (m) cov.push({
              x: m.tx,
              y: m.ty,
              st: m.det,
              en: m.det + 1.3,
              rAt: t => explRadius(t - m.det, m.blast, .36, 1.3)
            });
          }
          if (ei >= 0) en.splice(ei, 1);
          if (bi >= 0) bases.splice(bi, 1);
        }
        while (bases.length && ufo.length && shots < maxShotsBudget + 1) {
          let best = null,
            ui = -1,
            bi = -1;
          for (let i = 0; i < ufo.length; i++) {
            const u = ufo[i];
            for (let j = 0; j < bases.length; j++) {
              const b = bases[j],
                intr = interceptUfo(b, u, autoSpeed);
              if (!intr) {
                scan.ufo.noIntercept++;
                continue;
              }
              if (hitConflict(intr, cov, now)) {
                scan.ufo.conflict++;
                continue;
              }
              const s = threatUfo(u) - intr.t * 45 - Math.abs(b.x - intr.x) * .035;
              if (!best || s > best.s) {
                best = {
                  b,
                  u,
                  intr,
                  s
                };
                ui = i;
                bi = j;
              }
            }
          }
          if (!best) break;
          const fired = launchPlayer(best.intr.x, best.intr.y, best.b, {
            allowGround: true,
            fast: true,
            blast: 114,
            auto: true
          });
          if (fired) {
            debugRecord('auto_assignment', {
              baseId: best.b.id,
              targetType: 'ufo',
              targetId: best.u.id,
              enemyType: best.u.isBoss ? 'bossUfo' : 'ufo',
              intercept: {
                x: round3(best.intr.x),
                y: round3(best.intr.y),
                t: round3(best.intr.t)
              },
              score: round3(best.s)
            });
            shots++;
            const m = S.player[S.player.length - 1];
            if (m) {
              cov.push({
                x: m.tx,
                y: m.ty,
                st: m.det,
                en: m.det + 1.3,
                rAt: t => explRadius(t - m.det, m.blast, .36, 1.3)
              });
              best.u.autoReserve = m.det + 1.25;
            } else best.u.autoReserve = now + .8;
          }
          if (ui >= 0) ufo.splice(ui, 1);
          if (bi >= 0) bases.splice(bi, 1);
        }
        if (wave) {
          wave.stats.autoScan.enemy.covered += scan.enemy.covered;
          wave.stats.autoScan.enemy.noIntercept += scan.enemy.noIntercept;
          wave.stats.autoScan.enemy.late += scan.enemy.late;
          wave.stats.autoScan.enemy.conflict += scan.enemy.conflict;
          wave.stats.autoScan.ufo.noIntercept += scan.ufo.noIntercept;
          wave.stats.autoScan.ufo.conflict += scan.ufo.conflict;
        }
        debugRecord('auto_cycle', {
          baseCount: S.bases.filter(b => !b.destroyed).length,
          enemyVisible: S.enemy.length,
          ufoVisible: S.ufo.length,
          shotsFired: shots,
          shotBudget: maxShotsBudget,
          reject: scan
        });
      }

      function updateDanger() {
        if (S.intro || S.gameOver) {
          S.danger = 0;
          return;
        }
        const alive = Math.max(1, S.cities.filter(c => c.alive).length);
        let d = 0;
        for (const m of S.enemy) d += threat(m) / (tImpact(m) + 1.4);
        d += (S.wavePlan.length - S.spawnI) * 1.8;
        d += S.ufo.length * 52;
        d += S.raiders.length * 66;
        if (S.demon) d += 82;
        if (hellRaiserVulnerable()) d += 70;
        S.danger = clamp(d / (alive * 170), 0, 1);
      }

      function updEnemy(dt) {
        for (let i = S.enemy.length - 1; i >= 0; i--) {
          const m = S.enemy[i];
          m.el += dt;
          const p = m.dur > 0 ? m.el / m.dur : 1;
          if (m.v === 'split' && !m.split && p >= m.splitAt) {
            splitMissile(m);
            S.enemy.splice(i, 1);
            continue;
          }
          if (m.v === 'carrier' && !m.deployed && p >= m.deployAt) {
            deployCarrierDrones(m);
            audio.incoming(clamp(m.x / S.w, 0, 1), 1.0);
          }
          if (p >= 1) {
            S.enemy.splice(i, 1);
            impactEnemy(m, m.tx, m.ty);
            continue;
          }
          if ((m.homing ?? 0) > 0 && m.payload) {
            const tx = m.payload.x ?? m.tx,
              ty = m.payload.y ?? m.ty,
              desired = Math.atan2(ty - m.y, tx - m.x),
              cur = Math.atan2(m.vy, m.vx),
              diff = Math.atan2(Math.sin(desired - cur), Math.cos(desired - cur)),
              turn = clamp(diff, -1, 1) * (m.homing * dt * 2.2),
              sp = Math.hypot(m.vx, m.vy);
            const na = cur + turn;
            m.vx = Math.cos(na) * sp;
            m.vy = Math.sin(na) * sp;
          }
          const pos = mPos(m, S.time),
            vel = mVel(m, S.time);
          m.x = pos.x;
          m.y = pos.y;
          m.cv = vel.vx;
          m.cy = vel.vy;
          m.trail.unshift({
            x: m.x,
            y: m.y
          });
          if (m.trail.length > 52) m.trail.pop();
          m.trailT += dt;
          if (m.trailT >= .028) {
            spawnTrail(m.x, m.y, true, m.v, m.cv, m.cy);
            m.trailT = 0;
          }
          if (!m.warn && (m.y > S.groundY - 210 || m.v === 'cruise' && m.y > S.groundY - 280)) {
            m.warn = true;
            audio.incoming(m.x / S.w, m.v === 'heavy' || m.v === 'carrier' ? 1 : m.v === 'split' ? .75 : m.v === 'cruise' ? .92 : .55);
          }
          if (!m.near && m.y < S.groundY - 64) {
            const dxm = m.x - S.mouse.x,
              dym = m.y - S.mouse.y;
            if (dxm * dxm + dym * dym <= 145 * 145) {
              m.near = true;
              if (audio.nearMiss) audio.nearMiss(clamp(m.x / S.w, 0, 1), m.v === 'heavy' ? 1 : .72);
            }
          }
          if (m.y >= S.groundY - 4) {
            S.enemy.splice(i, 1);
            impactEnemy(m, m.x, S.groundY - 2);
          }
        }
      }

      function updUfo(dt) {
        for (let i = S.ufo.length - 1; i >= 0; i--) {
          const u = S.ufo[i];
          u.t += dt;
          u.x += u.vx * dt;
          u.y = u.baseY + Math.sin(S.time * u.bobSp + u.ph) * u.bobAmp;
          u.cool -= dt;
          if (u.cool <= 0) {
            spawnUfoBomb(u);
            u.cool = rand(1.15, 2.2);
          }
          if ((u.vx > 0 && u.x > S.w + 130) || (u.vx < 0 && u.x < -130)) S.ufo.splice(i, 1);
        }
      }

      function updRaiders(dt) {
        for (let i = S.raiders.length - 1; i >= 0; i--) {
          const r = S.raiders[i];
          r.turnT -= dt;
          r.spitT -= dt;
          if (r.turnT <= 0) {
            r.turnT = rand(.55, 1.25);
            r.vx = -r.vx * rand(.9, 1.22);
            spawnRaiderSpit(r, 3 + (Math.random() < .45 ? 2 : 1));
            audio.incoming(clamp(r.x / S.w, 0, 1), 1.08);
          }
          r.x += r.vx * dt;
          r.y += Math.sin(S.time * 2.7 + r.ph) * dt * 24;
          r.ang = Math.atan2(Math.cos(S.time * 2.7 + r.ph) * 24, r.vx);
          if (r.spitT <= 0) {
            r.spitT = rand(.85, 1.8);
            spawnRaiderSpit(r, 2 + (Math.random() < .28 ? 1 : 0));
          }
          if (r.x < -180 || r.x > S.w + 180) {
            S.raiders.splice(i, 1);
          }
        }
      }

      function updDemon(dt) {
        const d = S.demon;
        if (!d) return;
        d.life -= dt;
        if (d.life <= 0) {
          debugRecord('enemy_vehicle_despawn', {
            vehicle: 'daemon',
            reason: 'life_expired'
          });
          S.demon = null;
          note('Daemon banished', 1.0);
          return;
        }
        d.x += d.vx * dt;
        d.y = S.horizonY * .2 + Math.sin(S.time * 1.9 + d.ph) * 30;
        if (d.x < 70 || d.x > S.w - 70) d.vx *= -1;
        d.cool -= dt;
        d.havocT -= dt;
        if (d.cool <= 0) {
          d.cool = rand(.7, 1.35);
          const burst = 4 + Math.floor(rand(0, 3));
          for (let i = 0; i < burst; i++) {
            const t = chooseTarget('hell');
            if (!t) continue;
            createEnemyProjectile('hell', d.x + rand(-26, 26), d.y + rand(8, 16), t, {
              blast: rand(110, 162),
              amp: rand(18, 42),
              fq: rand(1.2, 2.6),
              homing: rand(.4, .75)
            });
          }
          S.flash = Math.max(S.flash, .07);
          S.shake = Math.max(S.shake, 4);
          if (audio.thunder) audio.thunder(clamp(d.x / S.w, 0, 1), .55);
        }
        if (d.havocT <= 0) {
          d.havocT = rand(1.4, 2.6);
          spawnExpl(d.x + rand(-30, 30), d.y + rand(-8, 8), {
            player: false,
            r: rand(44, 70),
            life: .75,
            sh: .3,
            flash: .1,
            noShake: true
          });
        }
      }

      function splashHellRaiser(x, y, blast, blastScale = .64) {
        if (!hellRaiserVulnerable()) return false;
        const hr = S.hellRaiser,
          top = hellRaiserTop(hr),
          reach = Math.max(24, blast * blastScale),
          d = Math.hypot(top.x - x, top.y - y);
        if (d > reach) return false;
        const dmg = clamp((1 - d / reach) * (blast / 54), .35, 3.4);
        return damageHellRaiser(dmg, top.x, top.y);
      }

      function damageHellRaiser(dmg = 1, x = null, y = null) {
        const hr = S.hellRaiser;
        if (!hellRaiserVulnerable(hr)) return false;
        const top = hellRaiserTop(hr),
          hx = x ?? top.x,
          hy = y ?? top.y;
        hr.hp -= dmg;
        debugRecord('asset_damaged', {
          asset: 'hellRaiser',
          at: {
            x: round3(hx),
            y: round3(hy)
          },
          damage: round3(dmg),
          hpAfter: round3(Math.max(0, hr.hp))
        });
        spawnExpl(hx + rand(-4, 4), hy + rand(-4, 4), {
          player: false,
          r: 34 + dmg * 8,
          life: .55,
          sh: .32,
          flash: .05,
          noShake: true
        });
        if (hr.hp <= 0) {
          hr.destroyed = true;
          hr.state = 'destroyed';
          hr.command = 'idle';
          hr.ammo = 0;
          hr.lift = Math.max(hr.lift, .45);
          hr.door = 1;
          spawnExpl(top.x, top.y, {
            player: false,
            r: 142,
            life: 1.25,
            sh: .24,
            flash: .26,
            heavy: true
          });
          spawnSmoke(top.x, top.y - 3, 16, 1.25);
          S.shake = Math.max(S.shake, 14);
          debugInc('assetsLost', 'hellRaiser');
          debugRecord('asset_destroyed', {
            asset: 'hellRaiser',
            id: 'HELL_RAISER',
            at: {
              x: round3(top.x),
              y: round3(top.y)
            }
          });
          note('Hell Raiser destroyed', 1.1);
        }
        return true;
      }

      function toggleHellRaiser() {
        const hr = S.hellRaiser;
        if (!hr || S.intro || S.gameOver || S.shop) return false;
        if (hr.destroyed) {
          S.msg = 'Hell Raiser destroyed';
          S.msgT = 1.0;
          return false;
        }
        if (hr.state === 'hidden') {
          if (hr.cool > 0) {
            S.msg = 'Hell Raiser rearming';
            S.msgT = 1.0;
            return false;
          }
          hr.command = 'deploy';
          debugRecord('defense_command', {
            defense: 'hellRaiser',
            command: 'deploy'
          });
          S.msg = 'Hell Raiser deploying';
          S.msgT = 1.1;
          return true;
        }
        if (hr.state === 'opening' || hr.state === 'rising' || hr.state === 'active') {
          hr.command = 'retract';
          debugRecord('defense_command', {
            defense: 'hellRaiser',
            command: 'retract'
          });
          S.msg = 'Hell Raiser retracting';
          S.msgT = 1.0;
          return true;
        }
        return false;
      }

      function hellRaiserTargetAlive(t) {
        if (!t?.o) return false;
        if (t.k === 'enemy') return S.enemy.includes(t.o);
        if (t.k === 'ufo') return S.ufo.includes(t.o);
        if (t.k === 'raider') return S.raiders.includes(t.o);
        if (t.k === 'demon') return S.demon === t.o;
        return false;
      }

      function hellRaiserTargetPoint(t, lead = .1) {
        if (!hellRaiserTargetAlive(t)) return null;
        const o = t.o;
        if (t.k === 'enemy') return {
          x: o.x + (o.cv ?? o.vx) * lead,
          y: o.y + (o.cy ?? o.vy) * lead
        };
        if (t.k === 'ufo') return {
          x: o.x + o.vx * lead,
          y: o.y
        };
        if (t.k === 'raider') return {
          x: o.x + o.vx * lead,
          y: o.y + Math.sin((S.time + lead) * 2.7 + o.ph) * 10
        };
        return {
          x: o.x,
          y: o.y
        };
      }

      function collectHellRaiserTargets(ox, oy, pressure = null) {
        const out = [];
        const add = (k, o, baseW) => {
          const dx = o.x - ox,
            dy = o.y - oy,
            dist = Math.hypot(dx, dy);
          if (dist > 900 || o.y > S.groundY + 18) return;
          const key = k === 'demon' ? 'demon' : `${k}:${o.id}`,
            load = pressure?.get(key) ?? 0,
            distW = 1 / (.38 + dist * .0034),
            w = Math.max(1, baseW * distW / (1 + load * 1.35));
          out.push({
            w,
            v: {
              k,
              o,
              key
            }
          });
        };
        for (const m of S.enemy) add('enemy', m, threat(m) + (m.payload?.type === 'city' ? 46 : 0));
        for (const u of S.ufo) add('ufo', u, threatUfo(u) + 58);
        for (const r of S.raiders) add('raider', r, 228 + (1 - clamp(r.hp / r.maxHp, 0, 1)) * 96);
        if (S.demon) add('demon', S.demon, 292);
        return out;
      }

      function pickHellRaiserShotTarget(ox, oy, pressure = null) {
        const pool = collectHellRaiserTargets(ox, oy, pressure);
        return pool.length ? pick(pool) : null;
      }

      function launchHellRaiserMissile(hr, tx, ty, speed = rand(820, 1040), target = null) {
        const top = hellRaiserTop(hr),
          sx = top.x + rand(-6, 6),
          sy = top.y - 6 + rand(-4, 4),
          dx = tx - sx,
          dy = ty - sy,
          dist = Math.max(80, Math.hypot(dx, dy)),
          travel = dist / speed,
          dur = travel + rand(.28, .74);
        S.player.push({
          id: S.id++,
          x: sx,
          y: sy,
          sx,
          sy,
          tx,
          ty,
          vx: dx / dur,
          vy: dy / dur,
          dur,
          el: 0,
          trail: [],
          trailT: 0,
          blast: (34 + rand(0, 12)) * (0.55 + (S.upgrades ? S.upgrades.blastScale : 1.0) * .45),
          det: S.time + dur,
          emp: false,
          hr: true,
          hrSp: speed,
          hrTurn: rand(5.6, 8.8),
          hrRetarget: rand(.07, .2),
          hrTarget: target ? {
            k: target.k,
            o: target.o,
            key: target.key
          } : null,
          squiggleAmp: rand(5, 13),
          squiggleFreq: rand(3.1, 6.8),
          squigglePhase: Math.random() * TAU
        });
        debugInc('defenseShots', 'hellRaiser');
        debugRecord('defense_fire', {
          defense: 'hellRaiser',
          mode: 'auto',
          shotId: S.id - 1,
          from: {
            x: round3(sx),
            y: round3(sy)
          },
          to: {
            x: round3(tx),
            y: round3(ty)
          },
          target: target ? {
            kind: target.k,
            key: target.key
          } : null
        });
      }

      function updHellRaiser(dt) {
        const hr = S.hellRaiser;
        if (!hr) return;
        if (hr.audioT > 0) hr.audioT = Math.max(0, hr.audioT - dt);
        if (hr.destroyed) return;
        const canOperate = !S.intro && !S.gameOver && !S.shop;
        if ((hr.state === 'active' || hr.state === 'opening' || hr.state === 'rising') && !canOperate) hr.command = 'retract';

        if (hr.state === 'hidden') {
          if (hr.cool > 0) hr.cool = Math.max(0, hr.cool - dt * Math.max(1, S.upgrades?.reloadMult ?? 1));
          if (hr.command === 'deploy' && hr.cool <= 0 && hr.ammo > 0) {
            hr.state = 'opening';
            hr.command = 'idle';
            debugRecord('defense_state', {
              defense: 'hellRaiser',
              state: 'opening'
            });
            note('Hell Raiser online', .85);
          }
          return;
        }

        if (hr.state === 'opening') {
          hr.door = Math.min(1, hr.door + dt * 2.7);
          if (hr.door >= 1) {
            hr.state = 'rising';
            debugRecord('defense_state', {
              defense: 'hellRaiser',
              state: 'rising'
            });
          }
          return;
        }

        if (hr.state === 'rising') {
          hr.lift = Math.min(1, hr.lift + dt * 1.95);
          if (hr.lift >= 1) {
            hr.state = 'active';
            hr.fireAcc = 0;
            hr.activeT = 6.4;
            hr.hp = hr.maxHp;
            debugRecord('defense_state', {
              defense: 'hellRaiser',
              state: 'active'
            });
            note('Hell Raiser barrage', .85);
          }
          return;
        }

        if (hr.state === 'active') {
          hr.activeT -= dt;
          if (hr.command === 'retract' || hr.activeT <= 0 || hr.ammo <= 0) {
            hr.state = 'lowering';
            hr.command = 'idle';
            debugRecord('defense_state', {
              defense: 'hellRaiser',
              state: 'lowering'
            });
            return;
          }
          const top = hellRaiserTop(hr),
            availableTargets = collectHellRaiserTargets(top.x, top.y);
          if (!availableTargets.length) {
            hr.fireAcc = Math.max(0, hr.fireAcc - dt * 22);
            return;
          }
          const fireRate = 95 + Math.min(52, S.level * 3.4);
          hr.fireAcc += dt * fireRate;
          let shots = 0;
          const pressure = new Map();
          const burstTargets = {};
          while (hr.fireAcc >= 1 && hr.ammo > 0 && shots < 22) {
            hr.fireAcc -= 1;
            hr.ammo--;
            shots++;
            const shotTarget = pickHellRaiserShotTarget(top.x, top.y, pressure);
            if (!shotTarget) break;
            pressure.set(shotTarget.key, (pressure.get(shotTarget.key) ?? 0) + 1);
            burstTargets[shotTarget.key] = (burstTargets[shotTarget.key] ?? 0) + 1;
            const aim = hellRaiserTargetPoint(shotTarget, rand(.05, .17));
            if (!aim) continue;
            let tx = aim.x + rand(-20, 20),
              ty = aim.y + rand(-18, 18);
            tx = clamp(tx, 20, S.w - 20);
            ty = clamp(ty, 24, S.groundY - 52);
            launchHellRaiserMissile(hr, tx, ty, rand(820, 1080), shotTarget);
          }
          if (shots > 0 && hr.audioT <= 0) {
            audio.hellRaiser(clamp(hr.x / S.w, 0, 1), Math.min(1.3, .58 + shots / 16));
            hr.audioT = .04;
          }
          if (shots > 0) {
            debugInc('defenseBursts', 'hellRaiser');
            debugRecord('defense_burst', {
              defense: 'hellRaiser',
              shots,
              targets: burstTargets,
              ammoAfter: hr.ammo
            });
          }
          return;
        }

        if (hr.state === 'lowering') {
          hr.lift = Math.max(0, hr.lift - dt * 2.15);
          if (hr.lift <= 0) {
            hr.state = 'closing';
            debugRecord('defense_state', {
              defense: 'hellRaiser',
              state: 'closing'
            });
          }
          return;
        }

        if (hr.state === 'closing') {
          hr.door = Math.max(0, hr.door - dt * 2.7);
          if (hr.door <= 0) {
            hr.state = 'cooldown';
            hr.cool = Math.max(1.4, 3.2 / Math.max(.6, S.upgrades?.reloadMult ?? 1));
            debugRecord('defense_state', {
              defense: 'hellRaiser',
              state: 'cooldown'
            });
          }
          return;
        }

        if (hr.state === 'cooldown') {
          hr.cool = Math.max(0, hr.cool - dt * Math.max(1, S.upgrades?.reloadMult ?? 1));
          if (hr.cool <= 0) {
            hr.state = 'hidden';
            hr.ammo = hr.maxAmmo;
            hr.hp = hr.maxHp;
            hr.fireAcc = 0;
            debugRecord('defense_state', {
              defense: 'hellRaiser',
              state: 'hidden'
            });
          }
        }
      }

      function updPhalanx(dt) {
        const p = S.phalanx;
        if (!p) return;
        const phEff = S.upgrades?.phalanxEff ?? 1.0;
        const phalanxCdMult = ((S.cities[2] && S.cities[2].alive) ? 2.2 : 1.0) * (1 + (phEff - 1) * .55);
        if (p.audioT > 0) p.audioT = Math.max(0, p.audioT - dt);
        if (p.cool > 0) p.cool = Math.max(0, p.cool - dt * phalanxCdMult);
        if (p.heat > 0) p.heat = Math.max(0, p.heat - dt * 1.25 * phalanxCdMult);
        if (S.intro || S.gameOver || p.destroyed) {
          p.target = null;
          p.targetKind = null;
          p.targetDist = 0;
          p.lockKey = null;
          p.fireAcc = 0;
          p.fireMix = 0;
          return;
        }
        const fireRange = 620 + Math.max(0, phEff - 1) * 110,
          lockRange = Math.max(fireRange * 2.15, S.w * 1.08);
        let best = phalanxAcquireTarget(p, lockRange, fireRange);
        p.target = best ? best.o : null;
        p.targetKind = best ? best.k : null;
        p.targetDist = best ? best.dist : 0;
        const lockKey = best ? `${best.k}:${best.k === 'demon' ? 'daemon' : best.o?.id}` : null;
        if (lockKey !== p.lockKey) {
          if (lockKey) {
            debugRecord('defense_lock', {
              defense: 'phalanx',
              lock: lockKey,
              dist: round3(best.dist),
              score: round3(best.score),
              payloadType: best.k === 'enemy' ? (best.payloadType ?? best.o?.payload?.type ?? null) : null,
              timeToImpact: best.k === 'enemy' ? round3(best.eta ?? tImpact(best.o)) : null,
              terminalPriority: !!best.terminal
            });
          }
          p.lockKey = lockKey;
        }
        if (!isFinite(p.aimAng)) p.aimAng = -Math.PI * .5;
        if (best) {
          const aimLead = phalanxLeadSec(best),
            predicted = phalanxTargetPoint(best, aimLead);
          let aimX = predicted ? predicted.x : best.x,
            aimY = predicted ? predicted.y : best.y;
          p.aimX = aimX;
          p.aimY = aimY;
          const desired = Math.atan2(aimY - (p.y - 44), aimX - p.x),
            turnRate = (2.8 + (1 - p.heat) * 2.4 + Math.min(1.3, S.level * .02)) * (1 + (phEff - 1) * .18),
            diff = angleDelta(p.aimAng, desired),
            step = turnRate * dt;
          p.aimAng += clamp(diff, -step, step);
          p.aimErr = Math.abs(diff);
        } else {
          p.aimX = p.x + Math.cos(p.aimAng) * 160;
          p.aimY = (p.y - 44) + Math.sin(p.aimAng) * 160;
          p.aimErr = Math.PI;
          p.fireMix = Math.max(0, p.fireMix - dt * 4.2);
          return;
        }
        const rangeMul = best.k === 'ufo' ? 1.08 : best.k === 'raider' ? 1.12 : best.k === 'demon' ? 1.18 : 1;
        const inRange = best.dist <= fireRange * (best.terminal ? 1.18 : rangeMul);
        const aligned = p.aimErr <= (best.k === 'ufo' ? .17 : best.terminal ? .22 : .14);
        if (!inRange || !aligned || p.ammo <= 0 || p.cool > 0) {
          p.fireMix = Math.max(0, p.fireMix - dt * 4.2);
          return;
        }
        const fireRate = ((p.heat > .72 ? 56 : 94) + Math.min(28, S.level * 2.2)) * (1 + (phEff - 1) * .4);
        p.fireAcc += dt * fireRate;
        let shots = 0,
          burstHits = 0,
          burstKills = 0,
          hitRadiusPeak = 0,
          missPeak = 0;
        const initialTargetType = best.k,
          initialTargetId = best.o?.id ?? (best.k === 'demon' ? 'daemon' : null),
          initialPayloadType = best.k === 'enemy' ? (best.payloadType ?? best.o?.payload?.type ?? null) : null,
          initialTimeToImpact = best.k === 'enemy' ? round3(best.eta ?? tImpact(best.o)) : null,
          initialTerminalPriority = !!best.terminal;
        const targetAlive = (k, o) => k === 'enemy' ? S.enemy.includes(o) : k === 'ufo' ? S.ufo.includes(o) : k === 'raider' ? S.raiders.includes(o) : k === 'demon' ? S.demon === o : false;
        while (p.fireAcc >= 1 && p.ammo > 0 && shots < 120) {
          p.fireAcc -= 1;
          p.ammo--;
          shots++;
          if (!best || !targetAlive(best.k, best.o)) break;
          const o = best.o,
            srcX = p.x,
            srcY = p.y - 53,
            aimQuality = clamp(1 - p.aimErr / .18, 0, 1),
            spread = best.k === 'enemy' ? (4 + (1 - aimQuality) * 8 + clamp(best.dist / fireRange - .55, 0, .9) * 5) : (5 + (1 - aimQuality) * 5),
            tx = p.aimX + rand(-spread, spread),
            ty = p.aimY + rand(-spread, spread);
          spawnPhalanxTracer(srcX, srcY, tx, ty);
          if (best.k === 'enemy') {
            const lead = phalanxLeadSec(best),
              predicted = phalanxTargetPoint(best, lead),
              px = predicted ? predicted.x : o.x,
              py = predicted ? predicted.y : o.y,
              speed = Math.hypot(o.cv ?? o.vx ?? 0, o.cy ?? o.vy ?? 0),
              miss = Math.hypot(tx - px, ty - py),
              missRadius = 24 + clamp(speed * .028, 0, 16) + (o.v === 'fast' ? 6 : o.v === 'zig' ? 8 : o.v === 'drone' ? 6 : o.v === 'cruise' ? 4 : 0) + Math.max(0, (best.dist / fireRange - .52) * 15),
              hitChance = clamp((1 - best.dist / fireRange) * .37 + .09, .08, .56) * (1 - o.res * .9) * (o.v === 'heavy' ? .6 : 1) * (1 + (phEff - 1) * .45) * (.52 + aimQuality * .78);
            hitRadiusPeak = Math.max(hitRadiusPeak, missRadius);
            missPeak = Math.max(missPeak, miss);
            if (miss < missRadius && Math.random() < hitChance) {
              const killed = damageEnemyUnit(o, o.x, o.y, o.v === 'carrier' ? .9 : 1);
              burstHits++;
              if (killed) burstKills++;
              audio.hit(o.x / S.w, killed ? .34 : .22);
              if (killed) {
                const i = S.enemy.indexOf(o);
                if (i >= 0) S.enemy.splice(i, 1);
                best = null;
                break;
              }
            }
          } else if (best.k === 'ufo') {
            const hitChance = clamp((1 - best.dist / (fireRange * 1.08)) * .42 + .08, .08, .44) * (1 + (phEff - 1) * .4) * (.48 + aimQuality * .82);
            if (Math.random() < hitChance) {
              o.hp--;
              burstHits++;
              spawnExpl(o.x + rand(-9, 9), o.y + rand(-5, 5), {
                player: true,
                r: 30,
                life: .43,
                sh: .34,
                flash: .03,
                noShake: true
              });
              if (o.hp <= 0) {
                burstKills++;
                const cityScoreMult = (S.cities[4] && S.cities[4].alive) ? 1.2 : 1.0;
                const baseUfoVal = o.isBoss ? 1500 : 260;
                const bonus = 1 + Math.min(2.2, S.combo * .09),
                  gain = Math.round(baseUfoVal * bonus * cityScoreMult);
                S.score += gain;
                S.combo++;
                S.comboTimer = 4;
                S.maxCombo = Math.max(S.maxCombo, S.combo);
                if (S.combo > 1 && S.combo % 5 === 0) {
                  S.floatingTexts.push({ text: `${S.combo}x COMBO!`, x: o.x, y: o.y - 40, life: 1.2 });
                }
                spawnExpl(o.x, o.y, {
                  player: true,
                  r: o.isBoss ? 140 : 96,
                  life: o.isBoss ? 1.4 : 1.02,
                  sh: .34,
                  flash: o.isBoss ? .32 : .18
                });
                spawnSmoke(o.x, o.y, o.isBoss ? 20 : 10, o.isBoss ? 1.3 : 1.05);
                audio.hit(o.x / S.w, o.isBoss ? 1.4 : 1.12);
                debugInc('enemyKilled', o.isBoss ? 'bossUfo' : 'ufo');
                debugRecord('enemy_killed', {
                  id: o.id,
                  enemyType: o.isBoss ? 'bossUfo' : 'ufo',
                  at: {
                    x: round3(o.x),
                    y: round3(o.y)
                  },
                  gain
                });
                note(o.isBoss ? 'Boss UFO destroyed' : 'UFO destroyed', .9);
                const i = S.ufo.indexOf(o);
                if (i >= 0) S.ufo.splice(i, 1);
                best = null;
                break;
              }
            }
          } else {
            const hitChance = clamp((1 - best.dist / (fireRange * rangeMul)) * .46 + .1, .1, .58) * (1 + (phEff - 1) * .35) * (.5 + aimQuality * .78);
            if (Math.random() < hitChance) {
              if (best.k === 'raider') o.hp -= 1;
              else if (best.k === 'demon') o.life -= .45;
              burstHits++;
              spawnExpl(o.x + rand(-8, 8), o.y + rand(-5, 5), {
                player: true,
                r: 38,
                life: .46,
                sh: .35,
                flash: .05,
                noShake: true
              });
              if (best.k === 'raider' && o.hp <= 0) {
                burstKills++;
                const bonus = 1 + Math.min(2.2, S.combo * .09),
                  gain = Math.round(460 * bonus);
                S.score += gain;
                S.combo++;
                S.comboTimer = 4;
                S.maxCombo = Math.max(S.maxCombo, S.combo);
                spawnExpl(o.x, o.y, {
                  player: true,
                  r: 116,
                  life: 1.1,
                  sh: .33,
                  flash: .24
                });
                spawnSmoke(o.x, o.y, 12, 1.1);
                debugInc('enemyKilled', 'raider');
                debugRecord('enemy_killed', {
                  id: o.id,
                  enemyType: 'raider',
                  at: {
                    x: round3(o.x),
                    y: round3(o.y)
                  },
                  gain
                });
                note('Stratospheric raider destroyed', .9);
                const i = S.raiders.indexOf(o);
                if (i >= 0) S.raiders.splice(i, 1);
                best = null;
                break;
              }
            }
          }
        }
        if (shots > 0) {
          debugInc('defenseShots', 'phalanx', shots);
          debugInc('defenseBursts', 'phalanx');
          debugRecord('defense_burst', {
            defense: 'phalanx',
            shots,
            hits: burstHits,
            kills: burstKills,
            targetType: initialTargetType,
            targetId: initialTargetId,
            payloadType: initialPayloadType,
            timeToImpact: initialTimeToImpact,
            terminalPriority: initialTerminalPriority,
            ammoAfter: p.ammo,
            aimErr: round3(p.aimErr),
            targetDist: round3(best ? best.dist : p.targetDist),
            hitRadiusPeak: round3(hitRadiusPeak),
            missPeak: round3(missPeak)
          });
          p.heat = Math.min(1, p.heat + shots * (.0036 / Math.max(1, phEff)));
          p.fireMix = Math.min(1, p.fireMix + shots * .03);
          if (p.audioT <= 0) {
            audio.phalanx(clamp(p.x / S.w, 0, 1), Math.min(1.1, shots / 16 + p.heat * .45));
            p.audioT = .03;
          }
        } else {
          p.fireMix = Math.max(0, p.fireMix - dt * 4.2);
        }
        if (p.ammo <= 0 && p.cool <= 0) {
          p.cool = 2.1 / Math.max(1, phEff);
          debugRecord('defense_state', {
            defense: 'phalanx',
            state: 'ammo_empty',
            cooldown: round3(p.cool)
          });
          note('Phalanx out of ammo', .75);
        }
      }

      function impactEnemy(m, x, y) {
        if (m.v === 'decoy') {
          spawnExpl(x, y, {
            player: false,
            r: 30,
            life: 0.8,
            sh: 0.3,
            flash: 0.05,
            noShake: true
          });
          return;
        }
        if (m.v === 'carrier' && !m.deployed) deployCarrierDrones(m);
        debugInc('enemyImpact', m.v);
        debugRecord('enemy_impact', {
          id: m.id,
          enemyType: m.v,
          at: {
            x: round3(x),
            y: round3(y)
          },
          blast: round3(m.blast),
          payload: targetSnapshot(m.payload)
        });
        const inferHeavy = m.v === 'heavy' || m.v === 'carrier' || m.v === 'hell';
        spawnExpl(x, y, {
          player: false,
          r: m.blast,
          life: inferHeavy ? 1.22 : m.v === 'drone' ? .82 : 1,
          sh: inferHeavy ? .24 : .3,
          flash: inferHeavy ? .28 : m.v === 'drone' ? .1 : .16,
          heavy: inferHeavy
        });
        spawnSmoke(x, y - 6, inferHeavy ? 18 : m.v === 'drone' ? 7 : 10, inferHeavy ? 1.35 : m.v === 'drone' ? .75 : 1);
        destroyTarget(m.payload, x, y, m.blast);
        splashHellRaiser(x, y, m.blast, m.v === 'drone' ? .45 : .62);
      }

      function updPlayer(dt) {
        for (let i = S.player.length - 1; i >= 0; i--) {
          const m = S.player[i];
          m.el += dt;
          if (m.hr) {
            m.hrRetarget = (m.hrRetarget ?? 0) - dt;
            if (m.hrRetarget <= 0 || !hellRaiserTargetAlive(m.hrTarget)) {
              const prevKey = m.hrTarget?.key ?? null;
              const nextTarget = pickHellRaiserShotTarget(m.x, m.y);
              m.hrTarget = nextTarget ? {
                k: nextTarget.k,
                o: nextTarget.o,
                key: nextTarget.key
              } : null;
              if ((m.hrTarget?.key ?? null) !== prevKey) {
                debugRecord('defense_retarget', {
                  defense: 'hellRaiser_missile',
                  shotId: m.id,
                  from: prevKey,
                  to: m.hrTarget?.key ?? null,
                  at: {
                    x: round3(m.x),
                    y: round3(m.y)
                  }
                });
              }
              m.hrRetarget = rand(.06, .18);
            }
            let ang = Math.atan2(m.vy, m.vx);
            const aim = hellRaiserTargetPoint(m.hrTarget, rand(.03, .12));
            if (aim) {
              const desired = Math.atan2(aim.y - m.y, aim.x - m.x),
                diff = Math.atan2(Math.sin(desired - ang), Math.cos(desired - ang));
              ang += clamp(diff, -(m.hrTurn ?? 6.2) * dt, (m.hrTurn ?? 6.2) * dt);
            }
            ang += Math.sin((S.time + m.id * .013) * (m.squiggleFreq ?? 4.4) + (m.squigglePhase ?? 0)) * dt * 1.35;
            const sp = m.hrSp ?? Math.max(1, Math.hypot(m.vx, m.vy));
            m.vx = Math.cos(ang) * sp;
            m.vy = Math.sin(ang) * sp;
            m.x += m.vx * dt;
            m.y += m.vy * dt;
            if (m.x < -60 || m.x > S.w + 60 || m.y < -40 || m.y > S.groundY + 28) m.el = m.dur;
          } else {
            m.x = m.sx + m.vx * m.el;
            m.y = m.sy + m.vy * m.el;
          }
          const p = m.dur > 0 ? m.el / m.dur : 1;
          if (p >= 1) {
            S.player.splice(i, 1);
            const ex = m.hr ? clamp(m.x, 0, S.w) : m.tx,
              ey = m.hr ? clamp(m.y, 18, S.groundY - 4) : m.ty;
            spawnExpl(ex, ey, {
              player: true,
              r: m.blast,
              life: m.hr ? .8 : m.emp ? 1.5 : 1.28,
              sh: .36,
              emp: m.emp,
              flash: m.hr ? .05 : m.emp ? .2 : .08
            });
            continue;
          }
          m.trail.unshift({
            x: m.x,
            y: m.y
          });
          if (m.trail.length > 46) m.trail.pop();
          m.trailT += dt;
          if (m.trailT >= .022) {
            spawnTrail(m.x, m.y, false, m.hr ? 'hellRaiser' : 'player', m.vx, m.vy);
            m.trailT = 0;
          }
        }
      }

      function updExpl(dt) {
        for (let i = S.expl.length - 1; i >= 0; i--) {
          const e = S.expl[i];
          e.el += dt;
          if (e.el >= e.life) {
            S.expl.splice(i, 1);
            continue;
          }
          e.r = explRadius(e.el, e.mr, e.sh, e.life);
        }
      }

      function updSmoke(dt) {
        for (let i = S.smoke.length - 1; i >= 0; i--) {
          const s = S.smoke[i];
          s.el += dt;
          if (s.el >= s.life) {
            S.smoke.splice(i, 1);
            continue;
          }
          const p = s.el / s.life;
          s.x += s.dr * dt * (.5 + p * .7);
          s.y -= s.rise * dt * (.7 + p * .45);
          s.dr *= .99;
        }
      }

      function updSparks(dt) {
        for (let i = S.sparks.length - 1; i >= 0; i--) {
          const s = S.sparks[i];
          s.el += dt;
          if (s.el >= s.life) {
            S.sparks.splice(i, 1);
            continue;
          }
          s.vy += s.emp ? 65 * dt : 140 * dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
          s.vx *= .994;
        }
      }

      function updTrails(dt) {
        for (let i = S.trails.length - 1; i >= 0; i--) {
          const p = S.trails[i];
          p.el += dt;
          if (p.el >= p.life) {
            S.trails.splice(i, 1);
            continue;
          }
          if (p.v === 'phalanx') {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vx *= .985;
            p.vy *= .985;
            continue;
          }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 35 * dt;
          p.vx *= .99;
        }
      }

      function updDebris(dt) {
        for (let i = S.debris.length - 1; i >= 0; i--) {
          const d = S.debris[i];
          d.el += dt;
          if (d.el >= d.life) {
            S.debris.splice(i, 1);
            continue;
          }
          d.vy += 360 * dt;
          d.x += d.vx * dt;
          d.y += d.vy * dt;
          d.rot += d.vr * dt;
          d.vx *= .992;
          if (d.y > S.groundY - 2) {
            d.y = S.groundY - 2;
            d.vy *= -0.26;
            d.vx *= .84;
            d.vr *= .7;
          }
          d.hot *= .988;
        }
      }

      function updShock(dt) {
        for (let i = S.shock.length - 1; i >= 0; i--) {
          const s = S.shock[i];
          s.el += dt;
          if (s.el >= s.life) {
            S.shock.splice(i, 1);
            continue;
          }
          const p = s.el / s.life;
          s.r = lerp(8, s.mr, easeOut(p));
        }
      }

      function updLightBursts(dt) {
        for (let i = S.lightBursts.length - 1; i >= 0; i--) {
          const l = S.lightBursts[i];
          l.el += dt;
          if (l.el >= l.life) {
            S.lightBursts.splice(i, 1);
            continue;
          }
        }
      }

      function updWeather(dt) {
        const w = S.weather;
        if (!w || !w.particles) return;
        w.wind += Math.sin(S.time * .07 + w.intensity * 4) * dt * 4;
        for (const p of w.particles) {
          p.x += (p.vx + w.wind * .2) * dt * p.z;
          p.y += p.vy * dt * p.z;
          if (p.y > S.h + 26) {
            p.y = -26;
            p.x = rand(-40, S.w + 40);
          }
          if (p.x < -60) p.x = S.w + 60;
          else if (p.x > S.w + 60) p.x = -60;
        }
        if (w.mode === 'storm' && !S.intro && !S.gameOver) {
          w.lightningT -= dt * (.6 + w.intensity * .9);
          if (w.lightningT <= 0) {
            S.flash = Math.max(S.flash, .08 + w.intensity * .18);
            w.lightningT = rand(2.4, 6.6) - w.intensity * 1.9;
            if (audio.thunder && w.thunderCd <= 0) {
              audio.thunder(rand(.15, .85), .45 + w.intensity * .55);
              w.thunderCd = rand(1.3, 2.7);
            }
          }
          if (w.thunderCd > 0) w.thunderCd = Math.max(0, w.thunderCd - dt);
        }
      }

      function regKill(m, x, y) {
        const cityScoreMult = (S.cities[4] && S.cities[4].alive) ? 1.2 : 1.0;
        const bonus = 1 + Math.min(2.2, S.combo * .09),
          gain = Math.round(m.val * bonus * cityScoreMult);
        S.score += gain;
        S.combo++;
        S.comboTimer = 4;
        S.maxCombo = Math.max(S.maxCombo, S.combo);
        if (S.combo > 1 && S.combo % 5 === 0) {
          S.floatingTexts.push({ text: `${S.combo}x COMBO!`, x, y: y - 20, life: 1.2 });
        }
        if (S.combo > 0 && S.combo % 12 === 0 && S.emp < S.empMax) {
          S.emp++;
          note('EMP charge granted', 1.25);
        }
        debugInc('enemyKilled', m.v);
        debugRecord('enemy_killed', {
          id: m.id,
          enemyType: m.v,
          at: {
            x: round3(x),
            y: round3(y)
          },
          gain,
          combo: S.combo
        });
        spawnExpl(x, y, {
          player: true,
          r: m.v === 'heavy' || m.v === 'carrier' ? 94 : m.v === 'cruise' ? 78 : 70,
          life: .9,
          sh: .41,
          flash: m.v === 'heavy' || m.v === 'carrier' ? .16 : .08,
          noShake: m.v !== 'heavy' && m.v !== 'carrier'
        });
      }

      function damageEnemyUnit(m, x, y, dmg = 1) {
        const hp = m.hp ?? 1;
        if (hp > dmg) {
          m.hp = hp - dmg;
          spawnExpl(x, y, {
            player: true,
            r: m.v === 'carrier' ? 56 : 34,
            life: .46,
            sh: .34,
            flash: .04,
            noShake: true
          });
          if (m.v === 'carrier' && !m.deployed && m.hp <= 1 && Math.random() < .65) deployCarrierDrones(m);
          return false;
        }
        regKill(m, x, y);
        return true;
      }

      function collisions() {
        for (let i = S.enemy.length - 1; i >= 0; i--) {
          const m = S.enemy[i];
          let removed = false;
          for (const e of S.expl) {
            if (!e.player) continue;
            const dx = m.x - e.x,
              dy = m.y - e.y,
              rf = 1 - m.res * (e.emp ? .15 : .45),
              r = Math.max(18, e.r * rf);
            if (dx * dx + dy * dy <= r * r) {
              const killed = damageEnemyUnit(m, m.x, m.y, e.emp ? 2.2 : 1);
              audio.hit(m.x / S.w, killed ? (m.v === 'heavy' || m.v === 'carrier' ? 1 : .65) : .28);
              removed = killed;
              break;
            }
          }
          if (removed) S.enemy.splice(i, 1);
        }
        for (let i = S.ufo.length - 1; i >= 0; i--) {
          const u = S.ufo[i];
          let hit = false;
          for (const e of S.expl) {
            if (!e.player) continue;
            const dx = u.x - e.x,
              dy = u.y - e.y,
              r = Math.max(22, e.r * .6);
            if (dx * dx + dy * dy <= r * r) {
              u.hp -= e.emp ? 4 : 1;
              hit = true;
              spawnExpl(u.x, u.y, {
                player: true,
                r: u.isBoss ? 64 : 44,
                life: .58,
                sh: .34,
                flash: .06,
                noShake: true
              });
              break;
            }
          }
          if (!hit) continue;
          if (u.hp <= 0) {
            const cityScoreMult = (S.cities[4] && S.cities[4].alive) ? 1.2 : 1.0;
            const baseUfoVal = u.isBoss ? 1500 : 260;
            const bonus = 1 + Math.min(2.2, S.combo * .09),
              gain = Math.round(baseUfoVal * bonus * cityScoreMult);
            S.score += gain;
            S.combo++;
            S.comboTimer = 4;
            S.maxCombo = Math.max(S.maxCombo, S.combo);
            if (S.combo > 1 && S.combo % 5 === 0) {
              S.floatingTexts.push({ text: `${S.combo}x COMBO!`, x: u.x, y: u.y - 40, life: 1.2 });
            }
            spawnExpl(u.x, u.y, {
              player: true,
              r: u.isBoss ? 140 : 96,
              life: u.isBoss ? 1.4 : 1.02,
              sh: .34,
              flash: u.isBoss ? .32 : .18
            });
            spawnSmoke(u.x, u.y, u.isBoss ? 20 : 10, u.isBoss ? 1.3 : 1.05);
            audio.hit(u.x / S.w, u.isBoss ? 1.4 : 1.12);
            debugInc('enemyKilled', u.isBoss ? 'bossUfo' : 'ufo');
            debugRecord('enemy_killed', {
              id: u.id,
              enemyType: u.isBoss ? 'bossUfo' : 'ufo',
              at: {
                x: round3(u.x),
                y: round3(u.y)
              },
              gain
            });
            note(u.isBoss ? 'Boss UFO destroyed' : 'UFO destroyed', .9);
            S.ufo.splice(i, 1);
          }
        }
        for (let i = S.raiders.length - 1; i >= 0; i--) {
          const r = S.raiders[i];
          let hit = false;
          for (const e of S.expl) {
            if (!e.player) continue;
            const dx = r.x - e.x,
              dy = r.y - e.y,
              rr = Math.max(26, e.r * .55);
            if (dx * dx + dy * dy <= rr * rr) {
              r.hp -= e.emp ? 3 : 1;
              hit = true;
              spawnExpl(r.x + rand(-8, 8), r.y + rand(-5, 5), {
                player: true,
                r: 42,
                life: .52,
                sh: .35,
                flash: .05,
                noShake: true
              });
              break;
            }
          }
          if (!hit) continue;
          if (r.hp <= 0) {
            const bonus = 1 + Math.min(2.2, S.combo * .09),
              gain = Math.round(460 * bonus);
            S.score += gain;
            S.combo++;
            S.comboTimer = 4;
            S.maxCombo = Math.max(S.maxCombo, S.combo);
            spawnExpl(r.x, r.y, {
              player: true,
              r: 116,
              life: 1.1,
              sh: .33,
              flash: .24
            });
            spawnSmoke(r.x, r.y, 12, 1.1);
            debugInc('enemyKilled', 'raider');
            debugRecord('enemy_killed', {
              id: r.id,
              enemyType: 'raider',
              at: {
                x: round3(r.x),
                y: round3(r.y)
              },
              gain
            });
            note('Stratospheric raider destroyed', .9);
            S.raiders.splice(i, 1);
          }
        }
      }

      function update(dt) {
        S.time += dt;
        if (S.floatingTexts && S.floatingTexts.length) {
          for (let i = S.floatingTexts.length - 1; i >= 0; i--) {
            S.floatingTexts[i].life -= dt;
            S.floatingTexts[i].y -= dt * 25;
            if (S.floatingTexts[i].life <= 0) S.floatingTexts.splice(i, 1);
          }
        }
        if (S.msgT > 0) S.msgT = Math.max(0, S.msgT - dt);
        if (S.noteT > 0) S.noteT = Math.max(0, S.noteT - dt);
        if (S.comboTimer > 0) {
          S.comboTimer = Math.max(0, S.comboTimer - dt);
          if (S.comboTimer === 0) S.combo = 0;
        }
        if (S.shake > 0) S.shake = Math.max(0, S.shake - dt * 20);
        if (S.flash > 0) S.flash = Math.max(0, S.flash - dt * 1.7);
        if (S.empCd > 0) S.empCd = Math.max(0, S.empCd - dt);
        updWeather(dt);
        if (S.gameOver) {
          updPlayer(dt);
          updEnemy(dt);
          updUfo(dt);
          updRaiders(dt);
          updDemon(dt);
          updHellRaiser(dt);
          updPhalanx(dt);
          updExpl(dt);
          updSmoke(dt);
          updSparks(dt);
          updTrails(dt);
          updDebris(dt);
          updShock(dt);
          updLightBursts(dt);
          collisions();
          audio.update({
            level: S.level,
            danger: S.danger,
            gameOver: true,
            lowAmmo: false,
            weather: S.weather.intensity,
            phalanxLevel: 0,
            phalanxPan: S.phalanx ? clamp(S.phalanx.x / S.w, 0, 1) : .5
          });
          return;
        }
        const city1Alive = S.cities[0]?.alive;
        if (city1Alive) {
          const liveBases = S.bases.filter(b => !b.destroyed);
          if (liveBases.length > 0) {
            const targetLow = S.auto ? 44 : 36,
              lowBases = liveBases.filter(b => b.ammo >= 0 && b.ammo < targetLow),
              totalAmmo = liveBases.reduce((n, b) => n + b.ammo, 0),
              emergency = totalAmmo <= Math.max(24, 8 + S.level * .9),
              supportRate = 0.18 + clamp((S.level - 12) * .012, 0, .28) + (S.auto ? .09 : 0) + S.danger * .16 + (emergency ? .32 : 0);
            if (lowBases.length > 0 && Math.random() < dt * supportRate) {
              const target = lowBases.reduce((p, n) => n.ammo < p.ammo ? n : p, lowBases[0]),
                grant = emergency && Math.random() < .4 ? 2 : 1;
              target.ammo = Math.min(180, target.ammo + grant);
            }
          }
        }
        for (const b of S.bases)
          if (b.cool > 0) b.cool = Math.max(0, b.cool - dt);
        if (!S.intro && !S.shop) {
          if (S.wavePause > 0) S.wavePause -= dt;
          else {
            S.waveTime += dt;
            while (S.spawnI < S.wavePlan.length && S.wavePlan[S.spawnI].at <= S.waveTime) {
              spawnEnemy(S.wavePlan[S.spawnI]);
              S.spawnI++;
            }
            if (S.ufoQuota > 0 && S.waveTime >= S.nextUfo) {
              if (spawnUfo()) S.ufoQuota--;
              S.nextUfo = S.waveTime + rand(8.1, 13.8) - Math.min(2.4, S.level * .14);
            }
            if (S.raiderQuota > 0 && S.waveTime >= S.nextRaider) {
              if (spawnRaider()) S.raiderQuota--;
              S.nextRaider = S.waveTime + rand(9.5, 15.5) - Math.min(2.1, S.level * .1);
            }
          }
        }
        updEnemy(dt);
        updUfo(dt);
        updRaiders(dt);
        updDemon(dt);
        updHellRaiser(dt);
        updPhalanx(dt);
        updPlayer(dt);
        updExpl(dt);
        updSmoke(dt);
        updSparks(dt);
        updTrails(dt);
        updDebris(dt);
        updShock(dt);
        updLightBursts(dt);
        collisions();
        if (S.auto && !S.intro && !S.shop) runAuto();
        if (!S.intro && !S.shop && S.spawnI >= S.wavePlan.length && S.enemy.length === 0 && S.ufo.length === 0 && S.raiders.length === 0 && S.expl.length === 0 && S.debris.length === 0 && S.shock.length === 0) {
          S.shop = true;
          S.shopTimer = 5.0;
          debugRecord('wave_cleared', {
            level: S.level,
            score: S.score,
            citiesAlive: S.cities.filter(c => c.alive).length
          });
          debugFinalizeWave('cleared', {
            score: S.score,
            citiesAlive: S.cities.filter(c => c.alive).length
          });
        }
        if (S.shop) {
          S.shopTimer -= dt;
          if (S.shopTimer <= 0) {
            S.shop = false;
            S.level++;
            startWave(2.9);
          }
        }
        const alive = S.cities.filter(c => c.alive).length;
        if (alive <= 0) {
          S.gameOver = true;
          debugFinalizeWave('game_over', {
            score: S.score
          });
          if (!S.gameOverSfx) {
            S.gameOverSfx = true;
            audio.over();
          }
          note('Defense grid collapsed', 2.2);
        }
        updateDanger();
        audio.update({
          level: S.level,
          danger: S.danger,
          gameOver: S.gameOver,
          weather: S.weather.intensity,
          lowAmmo: S.bases.reduce((n, b) => n + (b.destroyed ? 0 : b.ammo), 0) + (S.phalanx && !S.phalanx.destroyed ? S.phalanx.ammo : 0) + (S.hellRaiser && !S.hellRaiser.destroyed ? S.hellRaiser.ammo : 0) <= 18,
          phalanxLevel: S.phalanx && !S.phalanx.destroyed ? (S.phalanx.fireMix ?? 0) : 0,
          phalanxPan: S.phalanx ? clamp(S.phalanx.x / S.w, 0, 1) : .5
        });
      }

      function drawSky() {
        const light = skyCycle();
        const day = light.day;
        const twilight = light.twilight;
        const top = mixRgb(LIGHT_PALETTE.skyNight[0], LIGHT_PALETTE.skyDay[0], day);
        const mid = mixRgb(LIGHT_PALETTE.skyNight[1], LIGHT_PALETTE.skyDay[1], day);
        let low = mixRgb(LIGHT_PALETTE.skyNight[2], LIGHT_PALETTE.skyDay[2], day);
        low = mixRgb(low, [255, 164, 112], twilight * .24);
        const g = ctx.createLinearGradient(0, 0, 0, S.h);
        g.addColorStop(0, rgba(top));
        g.addColorStop(.36, rgba(mid));
        g.addColorStop(1, rgba(low));
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, S.w, S.h);
        const moonTrack = light.phase;
        const moonArc = Math.sin(moonTrack * Math.PI);
        const mx = lerp(-S.w * .12, S.w * 1.12, moonTrack);
        const my = lerp(S.horizonY * .95, S.horizonY * .2, moonArc) + Math.cos(moonTrack * TAU) * 6;
        const mr = Math.max(35, S.w * .0336);
        const moonVisRaw = clamp((.5 - day) / .22, 0, 1);
        const moonVis = moonVisRaw * moonVisRaw * (3 - 2 * moonVisRaw);
        const moonA = moonVis * .92 * clamp((moonArc + .06) / 1.06, 0, 1);
        if (moonA > .01) {
          let mg = ctx.createRadialGradient(mx, my, mr * .2, mx, my, mr * 1.7);
          mg.addColorStop(0, rgba(LIGHT_PALETTE.moonGlow, .18 + moonA * .2));
          mg.addColorStop(1, 'rgba(35,60,110,0)');
          ctx.fillStyle = mg;
          ctx.beginPath();
          ctx.arc(mx, my, mr * 1.7, 0, TAU);
          ctx.fill();
          mg = ctx.createRadialGradient(mx - mr * .18, my - mr * .18, mr * .15, mx, my, mr);
          mg.addColorStop(0, rgba(LIGHT_PALETTE.moon, .78 + moonA * .18));
          mg.addColorStop(1, rgba(LIGHT_PALETTE.moonGlow, .56 + moonA * .25));
          ctx.fillStyle = mg;
          ctx.beginPath();
          ctx.arc(mx, my, mr, 0, TAU);
          ctx.fill();
          const tex = moonTexture(mr);
          ctx.save();
          ctx.globalAlpha = .6 + moonA * .44;
          ctx.drawImage(tex, mx - mr, my - mr, mr * 2, mr * 2);
          ctx.restore();
          const term = ctx.createLinearGradient(mx - mr * .95, my - mr * .5, mx + mr * .95, my + mr * .55);
          term.addColorStop(0, `rgba(240,246,255,${.03 + moonA * .06})`);
          term.addColorStop(.46, 'rgba(0,0,0,0)');
          term.addColorStop(1, `rgba(62,82,126,${.24 + moonA * .2})`);
          ctx.fillStyle = term;
          ctx.beginPath();
          ctx.arc(mx, my, mr * .98, 0, TAU);
          ctx.fill();
        }
        const sunTrack = (moonTrack + .02) % 1;
        const sunArc = Math.sin(sunTrack * Math.PI);
        const sx = lerp(-S.w * .12, S.w * 1.12, sunTrack);
        const sy = lerp(S.horizonY * .95, S.horizonY * .24, sunArc) + Math.cos(sunTrack * TAU) * 5;
        const sr = Math.max(26, S.w * .024);
        const sunVisRaw = clamp((day - .58) / .22, 0, 1);
        const sunVis = sunVisRaw * sunVisRaw * (3 - 2 * sunVisRaw);
        const sunA = sunVis * clamp((sunArc + .08) / 1.08, 0, 1);
        if (sunA > .01) {
          let sg = ctx.createRadialGradient(sx, sy, sr * .16, sx, sy, sr * 2.4);
          sg.addColorStop(0, rgba(LIGHT_PALETTE.sunGlow, .3 + sunA * .42));
          sg.addColorStop(1, 'rgba(255,190,120,0)');
          ctx.fillStyle = sg;
          ctx.beginPath();
          ctx.arc(sx, sy, sr * 2.4, 0, TAU);
          ctx.fill();
          sg = ctx.createRadialGradient(sx - sr * .1, sy - sr * .1, sr * .08, sx, sy, sr * .84);
          sg.addColorStop(0, rgba(LIGHT_PALETTE.sun, .96));
          sg.addColorStop(1, rgba(LIGHT_PALETTE.sunGlow, .72 + sunA * .26));
          ctx.fillStyle = sg;
          ctx.beginPath();
          ctx.arc(sx, sy, sr * .84, 0, TAU);
          ctx.fill();
        }
        const hz = ctx.createLinearGradient(0, S.horizonY - 130, 0, S.horizonY + 120),
          dangerTint = clamp(S.danger * .45, 0, .4);
        const warm = Math.floor(148 + twilight * 92 + day * 24);
        const cool = Math.floor(128 + day * 54);
        const blue = Math.floor(190 + day * 18);
        const hazeA = .08 + twilight * .08 + day * .04;
        hz.addColorStop(0, rgba(mixRgb([96, 150, 255], [158, 190, 232], day), 0));
        hz.addColorStop(.5, `rgba(${warm + Math.floor(dangerTint * 80)},${cool + Math.floor(dangerTint * 40)},${blue},${hazeA})`);
        hz.addColorStop(1, 'rgba(255,90,70,0)');
        ctx.fillStyle = hz;
        ctx.fillRect(0, S.horizonY - 130, S.w, 260);
      }

      function drawNeb() {
        const light = skyCycle();
        const mx = (S.mouse.x - S.w * .5) / S.w;
        const my = (S.mouse.y - S.h * .5) / S.h;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = clamp(1 - light.day * 1.18, .04, 1);
        for (const n of S.nebula) {
          const x = n.x + Math.sin(S.time * n.d + n.p) * 22 - mx * 45,
            y = n.y + Math.cos(S.time * n.d * .8 + n.p * .6) * 16 - my * 25,
            r = n.r * (.85 + Math.sin(S.time * .22 + n.p) * .08),
            g = ctx.createRadialGradient(x, y, r * .2, x, y, r);
          g.addColorStop(0, `hsla(${n.h1},85%,74%,${n.a})`);
          g.addColorStop(.6, `hsla(${n.h2},75%,62%,${n.a * .5})`);
          g.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, TAU);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawAur() {
        const light = skyCycle();
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = clamp(.1 + light.night * 1.05, .1, 1);
        for (const b of S.aurora) {
          const g = ctx.createLinearGradient(0, b.y - b.th, 0, b.y + b.th);
          g.addColorStop(0, `hsla(${b.h},85%,60%,0)`);
          g.addColorStop(.45, `hsla(${b.h},92%,66%,${b.a})`);
          g.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.moveTo(0, b.y);
          for (let i = 0; i <= 24; i++) {
            const x = i / 24 * S.w,
              y = b.y + Math.sin(i * .42 + S.time * b.sp + b.p) * b.amp;
            ctx.lineTo(x, y);
          }
          ctx.lineTo(S.w, b.y + b.th);
          ctx.lineTo(0, b.y + b.th);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
      }

      function drawClouds() {
        const light = skyCycle();
        const cloudA = mixRgb([140, 174, 230], [220, 234, 248], light.day);
        const cloudB = mixRgb([86, 122, 188], [174, 196, 222], light.day);
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        for (const c of S.clouds) {
          const x = (c.x + S.time * c.sp) % (S.w + c.w * 1.2) - c.w * .6,
            y = c.y + Math.sin(S.time * .12 + c.p) * 16,
            w = c.w * (.92 + Math.sin(S.time * .08 + c.p) * .08),
            h = c.h * (.88 + Math.cos(S.time * .13 + c.p) * .12),
            g = ctx.createRadialGradient(x, y, 8, x, y, w * .62);
          g.addColorStop(0, rgba(cloudA, c.a * (.9 + light.day * .18)));
          g.addColorStop(.55, rgba(cloudB, c.a * (.45 + light.day * .2)));
          g.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.ellipse(x, y, w, h, 0, 0, TAU);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawStars() {
        const light = skyCycle();
        const visA = clamp(1 - light.day * 1.25, .02, 1);
        const visB = clamp(1 - light.day * 1.35, .01, 1);
        const moonTrack = light.phase,
          moonArc = Math.sin(moonTrack * Math.PI),
          moonX = lerp(-S.w * .12, S.w * 1.12, moonTrack),
          moonY = lerp(S.horizonY * .95, S.horizonY * .2, moonArc) + Math.cos(moonTrack * TAU) * 6,
          moonR = Math.max(35, S.w * .0336) * .92,
          moonVis = clamp((.5 - light.day) / .22, 0, 1);
        const sunTrack = (moonTrack + .02) % 1,
          sunArc = Math.sin(sunTrack * Math.PI),
          sunX = lerp(-S.w * .12, S.w * 1.12, sunTrack),
          sunY = lerp(S.horizonY * .95, S.horizonY * .24, sunArc) + Math.cos(sunTrack * TAU) * 5,
          sunR = Math.max(26, S.w * .024) * .84,
          sunVis = clamp((light.day - .58) / .22, 0, 1);
        const mx = (S.mouse.x - S.w * .5) / S.w,
          my = (S.mouse.y - S.h * .5) / S.h;
        ctx.save();
        for (const s of S.starsA) {
          const sx = s.x - mx * 10,
            sy = s.y - my * 8;
          if (moonVis > .02) {
            const dxm = sx - moonX,
              dym = sy - moonY;
            if (dxm * dxm + dym * dym <= moonR * moonR) continue;
          }
          if (sunVis > .02) {
            const dxs = sx - sunX,
              dys = sy - sunY;
            if (dxs * dxs + dys * dys <= sunR * sunR) continue;
          }
          const tw = s.a + Math.sin(S.time * s.s + s.p) * .13;
          ctx.globalAlpha = clamp(tw * visA, .01, 1);
          ctx.fillStyle = 'rgba(170,210,255,.8)';
          ctx.beginPath();
          ctx.arc(sx, sy, s.r, 0, TAU);
          ctx.fill();
        }
        ctx.restore();
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const s of S.starsB) {
          const sx = s.x - mx * 20,
            sy = s.y - my * 14;
          if (moonVis > .02) {
            const dxm = sx - moonX,
              dym = sy - moonY;
            if (dxm * dxm + dym * dym <= moonR * moonR) continue;
          }
          if (sunVis > .02) {
            const dxs = sx - sunX,
              dys = sy - sunY;
            if (dxs * dxs + dys * dys <= sunR * sunR) continue;
          }
          const tw = s.a + Math.sin(S.time * s.s + s.p) * .2;
          ctx.globalAlpha = clamp(tw * visB, .01, 1);
          ctx.fillStyle = 'rgba(210,243,255,.95)';
          ctx.beginPath();
          ctx.arc(sx, sy, s.r, 0, TAU);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawWeatherBack() {
        const w = S.weather;
        if (!w) return;
        const inten = clamp(w.intensity || 0, 0, 1);
        if (!w.fogBands?.length) return;
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        for (const b of w.fogBands) {
          const wob = Math.sin(S.time * b.sp + b.p),
            y = b.y + wob * 18;
          const g = ctx.createLinearGradient(0, y - b.th, 0, y + b.th);
          const color = w.mode === 'ash' ? [188, 140, 102] : [112, 162, 220];
          g.addColorStop(0, 'rgba(0,0,0,0)');
          g.addColorStop(.5, `rgba(${color[0]},${color[1]},${color[2]},${b.a * (.65 + inten * .55)})`);
          g.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = g;
          ctx.fillRect(0, y - b.th, S.w, b.th * 2);
        }
        ctx.restore();
      }

      function drawWeatherFront() {
        const w = S.weather;
        if (!w || !w.particles?.length) return;
        const inten = clamp(w.intensity || 0, 0, 1);
        const isRain = w.mode === 'storm';
        ctx.save();
        ctx.globalCompositeOperation = isRain ? 'screen' : 'lighter';
        for (const p of w.particles) {
          const a = p.a * (.45 + inten * .7);
          if (isRain) {
            ctx.strokeStyle = `hsla(${p.hue},85%,78%,${a})`;
            ctx.lineWidth = p.t;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + (w.wind * .015 + p.vx * .01) * p.z, p.y + p.len * p.z);
            ctx.stroke();
          } else {
            ctx.fillStyle = `hsla(${p.hue},86%,66%,${a})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.len * .55 * p.z, 0, TAU);
            ctx.fill();
          }
        }
        ctx.restore();
      }

      function drawMount() {
        const light = skyCycle();
        const mx = (S.mouse.x - S.w * .5) / S.w;
        const farTop = mixRgb(LIGHT_PALETTE.mountFarNight[0], LIGHT_PALETTE.mountFarDay[0], light.day);
        const farBot = mixRgb(LIGHT_PALETTE.mountFarNight[1], LIGHT_PALETTE.mountFarDay[1], light.day);
        const nearTop = mixRgb(LIGHT_PALETTE.mountNearNight[0], LIGHT_PALETTE.mountNearDay[0], light.day);
        const nearBot = mixRgb(LIGHT_PALETTE.mountNearNight[1], LIGHT_PALETTE.mountNearDay[1], light.day);
        ctx.save();
        let g = ctx.createLinearGradient(0, S.horizonY - 120, 0, S.groundY);
        g.addColorStop(0, rgba(farTop, .82 + light.day * .04));
        g.addColorStop(1, rgba(farBot, .95 - light.day * .06));
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(-S.w * .1, S.h);
        ctx.lineTo(S.mountFar[0].x - mx * 20, S.mountFar[0].y);
        for (const p of S.mountFar) ctx.lineTo(p.x - mx * 20, p.y);
        ctx.lineTo(S.w * 1.1, S.h);
        ctx.closePath();
        ctx.fill();
        g = ctx.createLinearGradient(0, S.horizonY - 30, 0, S.groundY + 40);
        g.addColorStop(0, rgba(nearTop, .86 + light.day * .03));
        g.addColorStop(1, rgba(nearBot, .98 - light.day * .08));
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(-S.w * .1, S.h);
        ctx.lineTo(S.mountNear[0].x - mx * 45, S.mountNear[0].y);
        for (const p of S.mountNear) ctx.lineTo(p.x - mx * 45, p.y);
        ctx.lineTo(S.w * 1.1, S.h);
        ctx.closePath();
        ctx.fill();
        if (light.day > .03 || light.twilight > .06) {
          const amb = mixRgb([84, 108, 152], [234, 204, 162], light.twilight * .45 + light.day * .2);
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = rgba(amb, .05 + light.day * .08 + light.twilight * .06);
          ctx.fillRect(0, S.horizonY - 60, S.w, S.groundY - S.horizonY + 120);
        }
        ctx.restore();
      }

      function drawGround() {
        const light = skyCycle();
        const gTopC = mixRgb(LIGHT_PALETTE.groundNight[0], LIGHT_PALETTE.groundDay[0], light.day);
        const gBotC = mixRgb(LIGHT_PALETTE.groundNight[1], LIGHT_PALETTE.groundDay[1], light.day);
        const g = ctx.createLinearGradient(0, S.groundY - 80, 0, S.h);
        g.addColorStop(0, rgba(gTopC));
        g.addColorStop(1, rgba(gBotC));
        ctx.fillStyle = g;
        ctx.fillRect(0, S.groundY - 8, S.w, S.h - S.groundY + 8);
        ctx.save();
        ctx.strokeStyle = rgba(mixRgb([109, 140, 190], [146, 158, 176], light.day), .08 + light.day * .04);
        ctx.lineWidth = 1;
        for (let i = 1; i <= 14; i++) {
          const y = lerp(S.groundY + 12, S.h, i / 14);
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(S.w, y);
          ctx.stroke();
        }
        for (let i = 0; i <= 26; i++) {
          const x = i / 26 * S.w;
          ctx.beginPath();
          ctx.moveTo(x, S.h);
          ctx.lineTo(lerp(x, S.w * .5, .63), S.groundY);
          ctx.stroke();
        }
        ctx.restore();
        const hazeCol = mixRgb([106, 148, 210], [154, 172, 194], light.day);
        for (const h of S.haze) {
          const wob = Math.sin(S.time * h.sp + h.p),
            y = h.y + wob * 16,
            gz = ctx.createLinearGradient(0, y - h.th, 0, y + h.th);
          gz.addColorStop(0, 'rgba(0,0,0,0)');
          gz.addColorStop(.5, rgba(hazeCol, h.a * (.82 + .18 * wob) * (1 - light.day * .24)));
          gz.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = gz;
          ctx.fillRect(0, y - h.th, S.w, h.th * 2);
        }
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const gridCol = mixRgb([120, 185, 255], [176, 200, 220], light.day);
        for (let i = 0; i < 24; i++) {
          const x = i / 23 * S.w,
            j = Math.sin(i * 1.7 + S.time * .8) * 4;
          ctx.fillStyle = rgba(gridCol, .018 + S.danger * .02 + light.day * .012);
          ctx.fillRect(x - 1, S.groundY - 5 + j, 2, 3);
        }
        ctx.restore();
      }

      function drawCities() {
        for (const c of S.cities) {
          ctx.save();
          ctx.translate(c.x - c.w * .5, c.y);
          if (c.alive) drawCity(c);
          else if (c.ruin) drawRuin(c);
          ctx.restore();
        }
      }

      function drawCity(c) {
        const base = ctx.createLinearGradient(0, -18, 0, 8);
        base.addColorStop(0, 'rgba(32,38,72,.95)');
        base.addColorStop(1, 'rgba(18,20,34,.96)');
        ctx.fillStyle = base;
        ctx.fillRect(-7, -5, c.w + 14, 7);
        ctx.fillStyle = 'rgba(124,178,255,.18)';
        ctx.fillRect(-5, -6, c.w + 10, 1.5);
        for (const b of c.profile) {
          ctx.save();
          ctx.translate(b.x0, 0);
          const face = ctx.createLinearGradient(0, -b.h, 0, 0),
            hA = Math.floor(76 + b.a * 92),
            hB = Math.floor(94 + b.a * 62);
          face.addColorStop(0, `rgba(${hA},${hB},235,.95)`);
          face.addColorStop(.7, 'rgba(34,42,86,.98)');
          face.addColorStop(1, 'rgba(20,23,44,.98)');
          ctx.fillStyle = face;
          ctx.fillRect(0, -b.h, b.w, b.h);
          if (b.step > 0) {
            const sw = b.w - b.step * 2,
              sh = b.stepH;
            ctx.fillStyle = 'rgba(18,24,50,.95)';
            ctx.fillRect(b.step, -b.h - sw * .01, sw, sh);
          }
          ctx.fillStyle = 'rgba(158,204,255,.26)';
          ctx.fillRect(b.w - 2.1, -b.h, 2.1, b.h);
          ctx.fillStyle = 'rgba(86,132,210,.2)';
          ctx.fillRect(0, -b.h, 1.6, b.h);
          if (b.roof > 0) {
            const rg = ctx.createLinearGradient(0, -b.h - b.roof, 0, -b.h);
            rg.addColorStop(0, 'rgba(205,224,250,.7)');
            rg.addColorStop(1, 'rgba(72,104,164,.92)');
            ctx.fillStyle = rg;
            ctx.fillRect(b.w * .14, -b.h - b.roof, b.w * .72, b.roof);
          }
          if (b.spire > 0) {
            ctx.strokeStyle = 'rgba(166,196,244,.75)';
            ctx.lineWidth = 1.05;
            ctx.beginPath();
            ctx.moveTo(b.w * .5, -b.h - (b.roof || 1));
            ctx.lineTo(b.w * .5, -b.h - (b.roof || 1) - b.spire);
            ctx.stroke();
          }
          if (b.ant > 0) {
            const ty = -b.h - (b.roof || 2) - b.ant;
            ctx.strokeStyle = 'rgba(150,176,220,.75)';
            ctx.lineWidth = 1.15;
            ctx.beginPath();
            ctx.moveTo(b.w * .5, -b.h - (b.roof || 2));
            ctx.lineTo(b.w * .5, ty);
            ctx.stroke();
            const bl = .38 + .62 * Math.max(0, Math.sin(S.time * 4.8 + b.a * 6));
            ctx.fillStyle = `rgba(255,124,124,${bl})`;
            ctx.beginPath();
            ctx.arc(b.w * .5, ty, 2.35, 0, TAU);
            ctx.fill();
          }
          for (const w of b.wins) {
            const f = .2 + w.g * (.55 + .45 * Math.sin(S.time * w.s + w.p));
            ctx.fillStyle = `rgba(${178 + b.a * 34},${232 + b.a * 20},255,${f})`;
            ctx.fillRect(w.x, w.y, w.w, w.h);
          }
          const ledgeY = -b.h * b.ledge;
          ctx.fillStyle = 'rgba(145,192,255,.22)';
          ctx.fillRect(1, ledgeY, b.w - 2, 1.2);
          ctx.restore();
        }
      }

      function drawRuin(c) {
        const r = c.ruin;
        if (!r) return;
        ctx.fillStyle = '#221a2a';
        ctx.fillRect(-6, -4, c.w + 12, 5);
        const sc = ctx.createRadialGradient(r.impact, -2, 4, r.impact, -2, r.scar);
        sc.addColorStop(0, 'rgba(255,146,90,.28)');
        sc.addColorStop(.45, 'rgba(72,36,44,.4)');
        sc.addColorStop(1, 'rgba(18,10,17,0)');
        ctx.fillStyle = sc;
        ctx.beginPath();
        ctx.ellipse(r.impact, -2, r.scar, r.scar * .33, 0, 0, TAU);
        ctx.fill();
        for (const f of r.fr) {
          ctx.save();
          ctx.translate(f.x, 0);
          const g = ctx.createLinearGradient(0, 0, 0, -f.h),
            k = 60 + f.t * 70;
          g.addColorStop(0, `rgba(${k - 24},36,${k - 28},.95)`);
          g.addColorStop(1, `rgba(${k + 14},70,${k + 6},.76)`);
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.moveTo(-f.w / 2, 0);
          ctx.lineTo(f.w / 2, 0);
          ctx.lineTo(f.w / 2 + f.l2 * f.w * .3, -f.h);
          ctx.lineTo(-f.w / 2 + f.l1 * f.w * .32, -f.h * f.n);
          ctx.closePath();
          ctx.fill();
          if (f.e) {
            const b = .34 + .66 * Math.max(0, Math.sin(S.time * 7 + f.gp));
            ctx.fillStyle = `rgba(255,118,72,${b})`;
            ctx.beginPath();
            ctx.arc(0, -f.h * .68, 2.4, 0, TAU);
            ctx.fill();
          }
          ctx.restore();
        }
        for (const e of r.emb) {
          const b = .42 + .58 * Math.sin(S.time * e.s + e.p);
          ctx.fillStyle = `rgba(255,160,90,${b * .72})`;
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.r, 0, TAU);
          ctx.fill();
        }
        const gl = .28 + .44 * Math.max(0, Math.sin(S.time * 4 + r.gp));
        ctx.fillStyle = `rgba(255,123,75,${gl})`;
        ctx.beginPath();
        ctx.arc(r.impact, -6, 4.8, 0, TAU);
        ctx.fill();
      }

      function drawBases() {
        for (const b of S.bases) {
          ctx.save();
          ctx.translate(b.x, b.y);
          if (b.destroyed) {
            ctx.fillStyle = 'rgba(58,42,56,.52)';
            ctx.beginPath();
            ctx.ellipse(0, 0, 40, 14, 0, 0, TAU);
            ctx.fill();
            ctx.fillStyle = 'rgba(96,58,80,.42)';
            ctx.fillRect(-18, -18, 12, 18);
            ctx.fillRect(7, -12, 10, 12);
            ctx.strokeStyle = 'rgba(255,120,92,.45)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-20, -2);
            ctx.lineTo(16, -10);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255,150,130,.82)';
            ctx.font = '700 14px "Orbitron","Trebuchet MS",sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('X', 0, -78);
            ctx.restore();
            continue;
          }
          const ar = b.ammo / Math.max(1, 16 + Math.floor(S.level * 2.2)),
            core = .42 + .58 * Math.max(0, Math.sin(S.time * 4 + b.x * .01)),
            pulse = .3 + .7 * Math.max(0, Math.sin(S.time * 5.2 + b.x * .017));
          ctx.fillStyle = '#1c1c31';
          ctx.beginPath();
          ctx.ellipse(0, 0, 41, 16, 0, 0, TAU);
          ctx.fill();
          ctx.fillStyle = 'rgba(88,126,198,.25)';
          ctx.beginPath();
          ctx.ellipse(0, -2, 31, 10, 0, 0, TAU);
          ctx.fill();
          const shaft = ctx.createLinearGradient(0, -60, 0, 0);
          shaft.addColorStop(0, 'rgba(108,140,228,.95)');
          shaft.addColorStop(1, 'rgba(40,48,92,.98)');
          ctx.fillStyle = shaft;
          ctx.fillRect(-12, -46, 24, 46);
          ctx.fillStyle = 'rgba(128,165,240,.85)';
          ctx.fillRect(-14, -46, 28, 5);
          ctx.fillStyle = 'rgba(160,214,255,.3)';
          ctx.fillRect(-9, -43, 4, 40);
          ctx.fillRect(5, -43, 4, 40);
          ctx.fillStyle = 'rgba(116,148,242,.96)';
          ctx.beginPath();
          ctx.moveTo(-21, -46);
          ctx.lineTo(21, -46);
          ctx.lineTo(10, -62);
          ctx.lineTo(-10, -62);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = 'rgba(86,120,215,.95)';
          ctx.fillRect(-4, -72, 8, 10);
          ctx.fillStyle = 'rgba(170,236,255,.84)';
          ctx.beginPath();
          ctx.arc(0, -23, 8 + ar * 4.2, 0, TAU);
          ctx.fill();
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          ctx.fillStyle = `rgba(136,246,255,${(.24 + core * .52) * ar})`;
          ctx.beginPath();
          ctx.arc(0, -23, 14 + ar * 6.5, 0, TAU);
          ctx.fill();
          ctx.restore();
          ctx.strokeStyle = 'rgba(118,200,255,.56)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(0, -23, 17, 0, TAU);
          ctx.stroke();
          ctx.fillStyle = `rgba(170,242,255,${.34 + pulse * .5})`;
          ctx.fillRect(-1.2, -74, 2.4, 9);
          ctx.fillStyle = 'rgba(186,248,255,.96)';
          ctx.font = '700 14px "Orbitron","Trebuchet MS",sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(String(b.ammo), 0, -82);
          ctx.restore();
        }
      }

      function drawHellRaiser() {
        const hr = S.hellRaiser;
        if (!hr) return;
        ctx.save();
        ctx.translate(hr.x, hr.y);
        const vulnerable = hellRaiserVulnerable(hr),
          hpRatio = hr.maxHp > 0 ? clamp(hr.hp / hr.maxHp, 0, 1) : 0;
        ctx.fillStyle = 'rgba(22,24,38,.96)';
        ctx.beginPath();
        ctx.ellipse(0, 2, 52, 16, 0, 0, TAU);
        ctx.fill();
        ctx.fillStyle = 'rgba(80,86,112,.42)';
        ctx.fillRect(-45, -7, 90, 7);
        ctx.fillStyle = 'rgba(124,136,178,.22)';
        ctx.fillRect(-36, -7, 72, 2.2);
        ctx.fillStyle = 'rgba(42,44,62,.96)';
        ctx.fillRect(-34, -5.5, 68, 5.5);
        const slide = hr.door * 20;
        ctx.fillStyle = hr.destroyed ? 'rgba(92,58,56,.78)' : 'rgba(106,118,148,.96)';
        ctx.fillRect(-34 - slide, -5.2, 30, 4.8);
        ctx.fillRect(4 + slide, -5.2, 30, 4.8);
        if (hr.door > .04 || hr.lift > .04 || hr.destroyed) {
          const shaftGlow = vulnerable ? .22 + (1 - hpRatio) * .2 : .08;
          ctx.fillStyle = `rgba(255,132,96,${shaftGlow})`;
          ctx.fillRect(-9, -4.8, 18, 4.8);
          ctx.fillStyle = 'rgba(34,28,46,.98)';
          ctx.fillRect(-8.5, -78, 17, 73);
        }
        if (hr.lift > 0.01 || hr.destroyed) {
          const y = -7 - hr.lift * 72;
          ctx.fillStyle = hr.destroyed ? 'rgba(96,62,54,.92)' : 'rgba(118,124,146,.97)';
          ctx.fillRect(-10, y - 24, 20, 24);
          ctx.fillStyle = hr.destroyed ? 'rgba(120,64,56,.92)' : 'rgba(164,170,198,.95)';
          ctx.fillRect(-12, y - 24, 24, 4.4);
          if (!hr.destroyed) {
            for (let row = 0; row < 4; row++) {
              for (let col = 0; col < 3; col++) {
                const mx = -6 + col * 6,
                  my = y - 20 + row * 5,
                  pulse = .38 + .62 * Math.max(0, Math.sin(S.time * 9 + row * .9 + col * 1.1 + hr.x * .01));
                ctx.fillStyle = `rgba(255,196,136,${.3 + pulse * .4})`;
                ctx.beginPath();
                ctx.arc(mx, my, 1.2, 0, TAU);
                ctx.fill();
              }
            }
          }
          ctx.fillStyle = hr.destroyed ? 'rgba(72,36,34,.9)' : 'rgba(88,96,126,.98)';
          ctx.fillRect(-6, y - 40, 12, 16);
          if (!hr.destroyed) {
            ctx.fillStyle = 'rgba(255,96,72,.95)';
            ctx.fillRect(-5.5, y - 41.5, 11 * hpRatio, 1.8);
          }
        }
        if (vulnerable && !hr.destroyed) {
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          ctx.fillStyle = `rgba(255,116,86,${.14 + (1 - hpRatio) * .22})`;
          ctx.beginPath();
          ctx.ellipse(0, -38, 40, 14, 0, 0, TAU);
          ctx.fill();
          ctx.restore();
          ctx.fillStyle = 'rgba(255,220,180,.94)';
          ctx.font = '700 12px "Orbitron","Trebuchet MS",sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(String(Math.max(0, Math.floor(hr.ammo))), 0, -92);
        }
        if (hr.state === 'active' && !hr.destroyed) {
          ctx.fillStyle = `rgba(255,146,108,${.45 + Math.sin(S.time * 14) * .16})`;
          ctx.beginPath();
          ctx.arc(0, -44, 2.2, 0, TAU);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawPhalanx() {
        const p = S.phalanx;
        if (!p) return;
        ctx.save();
        ctx.translate(p.x, p.y);
        if (p.destroyed) {
          ctx.fillStyle = 'rgba(62,46,40,.62)';
          ctx.beginPath();
          ctx.ellipse(0, 0, 28, 10, 0, 0, TAU);
          ctx.fill();
          ctx.fillStyle = 'rgba(102,70,55,.45)';
          ctx.fillRect(-12, -18, 24, 18);
          ctx.strokeStyle = 'rgba(255,130,90,.42)';
          ctx.lineWidth = 1.8;
          ctx.beginPath();
          ctx.moveTo(-11, -4);
          ctx.lineTo(11, -13);
          ctx.stroke();
          ctx.restore();
          return;
        }
        const ang = isFinite(p.aimAng) ? p.aimAng : -Math.PI * .5,
          heat = p.heat,
          lock = p.target ? 1 : 0,
          pulse = .38 + .62 * Math.max(0, Math.sin(S.time * 8.5 + p.x * .01));

        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = 'rgba(0,0,0,.22)';
        ctx.beginPath();
        ctx.ellipse(0, 5, 40, 12, 0, 0, TAU);
        ctx.fill();
        ctx.restore();

        const deck = ctx.createLinearGradient(0, -10, 0, 12);
        deck.addColorStop(0, 'rgba(118,126,138,.98)');
        deck.addColorStop(1, 'rgba(64,70,80,.98)');
        ctx.fillStyle = deck;
        ctx.beginPath();
        ctx.ellipse(0, 0, 36, 12, 0, 0, TAU);
        ctx.fill();

        ctx.strokeStyle = 'rgba(170,182,198,.55)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(0, 0, 31, 9.6, 0, 0, TAU);
        ctx.stroke();
        for (let i = 0; i < 22; i++) {
          const t = i / 22 * TAU,
            r1 = 24.5,
            r2 = 28.6;
          ctx.strokeStyle = 'rgba(56,64,74,.66)';
          ctx.beginPath();
          ctx.moveTo(Math.cos(t) * r1, Math.sin(t) * r1 * .33);
          ctx.lineTo(Math.cos(t) * r2, Math.sin(t) * r2 * .33);
          ctx.stroke();
        }

        const pedestal = ctx.createLinearGradient(0, -64, 0, -6);
        pedestal.addColorStop(0, 'rgba(170,178,192,.98)');
        pedestal.addColorStop(.45, 'rgba(112,124,138,.98)');
        pedestal.addColorStop(1, 'rgba(72,80,92,.98)');
        ctx.fillStyle = pedestal;
        ctx.beginPath();
        ctx.moveTo(-16, -6);
        ctx.lineTo(16, -6);
        ctx.lineTo(12, -60);
        ctx.lineTo(-12, -60);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'rgba(88,96,108,.92)';
        ctx.fillRect(-10, -72, 20, 12);
        ctx.fillStyle = 'rgba(190,204,220,.74)';
        ctx.fillRect(-8, -72, 8, 2.2);

        ctx.fillStyle = 'rgba(202,210,220,.95)';
        ctx.beginPath();
        ctx.ellipse(-2, -95, 14, 22, 0, 0, TAU);
        ctx.fill();
        ctx.fillStyle = 'rgba(152,162,176,.95)';
        ctx.fillRect(-16, -95, 14, 22);
        ctx.fillStyle = 'rgba(108,118,132,.95)';
        ctx.fillRect(-16, -73, 14, 4);
        for (let i = 0; i < 8; i++) {
          ctx.fillStyle = 'rgba(122,134,148,.82)';
          ctx.beginPath();
          ctx.arc(-16 + (i % 2 ? 11 : 3), -92 + Math.floor(i / 2) * 6, .9, 0, TAU);
          ctx.fill();
        }

        ctx.save();
        ctx.translate(0, -52);
        ctx.rotate(ang);
        const cradle = ctx.createLinearGradient(-16, -10, 24, 10);
        cradle.addColorStop(0, 'rgba(88,98,112,.98)');
        cradle.addColorStop(.5, 'rgba(164,176,192,.98)');
        cradle.addColorStop(1, 'rgba(74,82,96,.98)');
        ctx.fillStyle = cradle;
        ctx.fillRect(-16, -11, 33, 22);
        ctx.fillStyle = 'rgba(58,66,78,.9)';
        ctx.beginPath();
        ctx.moveTo(-8, -7);
        ctx.lineTo(2, 0);
        ctx.lineTo(-8, 7);
        ctx.moveTo(6, -7);
        ctx.lineTo(16, 0);
        ctx.lineTo(6, 7);
        ctx.stroke();

        const barrelBase = ctx.createLinearGradient(0, -6, 26, 6);
        barrelBase.addColorStop(0, 'rgba(122,132,146,.98)');
        barrelBase.addColorStop(1, 'rgba(58,66,78,.98)');
        ctx.fillStyle = barrelBase;
        ctx.fillRect(8, -5.2, 31, 10.4);
        ctx.fillStyle = 'rgba(42,48,58,.95)';
        ctx.beginPath();
        ctx.arc(10, 0, 6.3, 0, TAU);
        ctx.fill();

        const spin = S.time * (4.8 + heat * 12);
        for (let i = 0; i < 6; i++) {
          const t = spin + i / 6 * TAU,
            by = Math.sin(t) * 3.4;
          ctx.strokeStyle = 'rgba(80,90,104,.95)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(10, by);
          ctx.lineTo(41, by * .92);
          ctx.stroke();
          ctx.fillStyle = 'rgba(136,146,162,.98)';
          ctx.beginPath();
          ctx.arc(41.5, by * .92, 1.25, 0, TAU);
          ctx.fill();
        }

        ctx.fillStyle = 'rgba(36,42,50,.95)';
        ctx.beginPath();
        ctx.arc(42, 0, 4.6, 0, TAU);
        ctx.fill();
        ctx.fillStyle = 'rgba(188,198,210,.84)';
        for (let i = 0; i < 6; i++) {
          const t = spin + i / 6 * TAU;
          ctx.beginPath();
          ctx.arc(42 + Math.cos(t) * 2.3, Math.sin(t) * 2.3, .58, 0, TAU);
          ctx.fill();
        }

        if (p.fireMix > .12) {
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          const muzzle = .12 + p.fireMix * (.32 + heat * .25);
          ctx.fillStyle = `rgba(255,212,144,${muzzle})`;
          ctx.beginPath();
          ctx.ellipse(46, 0, 6 + p.fireMix * 5, 3.2 + p.fireMix * 2, 0, 0, TAU);
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = `rgba(162,238,255,${(.22 + pulse * .4) * (1 - heat * .2)})`;
        ctx.beginPath();
        ctx.arc(0, -66, 3.2, 0, TAU);
        ctx.fill();
        if (lock > 0) {
          ctx.fillStyle = `rgba(255,212,140,${.22 + lock * .22})`;
          ctx.beginPath();
          ctx.arc(0, -78, 2.3, 0, TAU);
          ctx.fill();
        }
        ctx.restore();

        ctx.fillStyle = 'rgba(255,236,176,.95)';
        ctx.font = '700 12px "Orbitron","Trebuchet MS",sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(String(p.ammo), 0, -61);
        ctx.restore();
      }

      function drawUfo() {
        for (const u of S.ufo) {
          ctx.save();
          ctx.translate(u.x, u.y);
          if (u.isBoss) ctx.scale(1.4, 1.4);

          const hpPercent = clamp(u.hp / u.maxHp, 0, 1),
            damage = 1 - hpPercent,
            wob = Math.sin(S.time * 3.2 + u.ph),
            glow = .42 + .58 * Math.max(0, wob);

          ctx.save();
          ctx.globalCompositeOperation = 'multiply';
          ctx.fillStyle = `rgba(0,0,0,${.26 + damage * .2})`;
          ctx.beginPath();
          ctx.ellipse(0, 10, 42, 12, 0, 0, TAU);
          ctx.fill();
          ctx.restore();

          if (u.hp > 2 && u.isBoss) {
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            const shieldPulse = .86 + Math.sin(S.time * 10 + u.id) * .12;
            ctx.strokeStyle = `rgba(110,188,255,${(.26 + hpPercent * .24) * shieldPulse})`;
            ctx.fillStyle = `rgba(72,124,205,${(.06 + hpPercent * .05) * shieldPulse})`;
            ctx.lineWidth = 2.4;
            ctx.beginPath();
            ctx.ellipse(0, -1, 47 * shieldPulse, 29 * shieldPulse, 0, 0, TAU);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          }

          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          const halo = ctx.createRadialGradient(0, 5, 6, 0, 5, 44);
          halo.addColorStop(0, `rgba(108,236,222,${.18 + glow * .18})`);
          halo.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = halo;
          ctx.beginPath();
          ctx.ellipse(0, 5, 40, 14, 0, 0, TAU);
          ctx.fill();
          ctx.restore();

          const hull = ctx.createLinearGradient(0, -12, 0, 12);
          hull.addColorStop(0, 'rgba(212,222,228,.98)');
          hull.addColorStop(.22, 'rgba(154,173,182,.98)');
          hull.addColorStop(.62, 'rgba(88,108,118,.98)');
          hull.addColorStop(1, 'rgba(46,58,66,.99)');
          ctx.fillStyle = hull;
          ctx.beginPath();
          ctx.ellipse(0, 0, 28, 10.6, 0, 0, TAU);
          ctx.fill();

          ctx.save();
          ctx.beginPath();
          ctx.ellipse(0, 0, 27.5, 10, 0, 0, TAU);
          ctx.clip();
          ctx.strokeStyle = 'rgba(74,90,104,.48)';
          ctx.lineWidth = .85;
          for (let i = -3; i <= 3; i++) {
            ctx.beginPath();
            ctx.moveTo(-26, i * 2.2 + Math.sin(S.time * .9 + i + u.id) * .35);
            ctx.lineTo(26, i * 2.2 - Math.sin(S.time * .7 + i * .4 + u.id) * .35);
            ctx.stroke();
          }
          ctx.restore();

          ctx.strokeStyle = 'rgba(196,214,222,.68)';
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.ellipse(0, 0.5, 28, 10.6, 0, 0, TAU);
          ctx.stroke();

          const dome = ctx.createRadialGradient(-2, -10.5, 1, 1, -7.8, 16);
          dome.addColorStop(0, 'rgba(234,246,252,.97)');
          dome.addColorStop(.44, 'rgba(126,156,174,.9)');
          dome.addColorStop(1, 'rgba(52,66,84,.9)');
          ctx.fillStyle = dome;
          ctx.beginPath();
          ctx.ellipse(0, -8.4, 13.8, 8.3, 0, Math.PI, TAU);
          ctx.fill();

          ctx.fillStyle = 'rgba(18,30,40,.78)';
          ctx.beginPath();
          ctx.ellipse(0, -7.2, 7.8, 3.3, 0, Math.PI, TAU);
          ctx.fill();
          ctx.fillStyle = 'rgba(244,252,255,.5)';
          ctx.fillRect(-6.2, -12.8, 8.6, 1.25);

          for (let i = 0; i < 8; i++) {
            const t = i / 8 * TAU,
              x = Math.cos(t) * 21,
              y = Math.sin(t) * 5.4 + 2.5,
              blink = .34 + .66 * Math.max(0, Math.sin(S.time * 6.4 + i * .85 + u.id * .4));
            ctx.fillStyle = i % 2 ? `rgba(136,236,255,${blink * .85})` : `rgba(255,180,128,${blink * .72})`;
            ctx.beginPath();
            ctx.arc(x, y, 1.2, 0, TAU);
            ctx.fill();
          }

          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          const eng = .35 + glow * .45;
          ctx.fillStyle = `rgba(120,242,255,${eng * (1 - damage * .45)})`;
          ctx.beginPath();
          ctx.ellipse(-11.8, 8.1, 5.6, 2.3, 0, 0, TAU);
          ctx.ellipse(0, 8.8, 6.2, 2.6, 0, 0, TAU);
          ctx.ellipse(11.8, 8.1, 5.6, 2.3, 0, 0, TAU);
          ctx.fill();
          ctx.restore();

          if (damage > .08) {
            ctx.strokeStyle = `rgba(60,40,34,${damage * .6})`;
            ctx.lineWidth = 1.1;
            ctx.beginPath();
            ctx.moveTo(-8, 1);
            ctx.lineTo(-2, -1.8);
            ctx.moveTo(6, 2.4);
            ctx.lineTo(13, .2);
            ctx.stroke();
          }
          ctx.restore();
        }
      }

      function drawRaiders() {
        for (const r of S.raiders) {
          ctx.save();
          ctx.translate(r.x, r.y);
          ctx.rotate(r.ang || 0);
          const hpRatio = clamp(r.hp / r.maxHp, 0, 1),
            damage = 1 - hpRatio;

          ctx.save();
          ctx.globalCompositeOperation = 'multiply';
          ctx.fillStyle = `rgba(0,0,0,${.22 + damage * .24})`;
          ctx.beginPath();
          ctx.ellipse(0, 8, 52, 12, 0, 0, TAU);
          ctx.fill();
          ctx.restore();

          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = `rgba(255,154,102,${.14 + damage * .24})`;
          ctx.beginPath();
          ctx.ellipse(-10, 2, 48, 14, 0, 0, TAU);
          ctx.fill();
          ctx.restore();

          const fus = ctx.createLinearGradient(-36, -11, 30, 12);
          fus.addColorStop(0, 'rgba(90,108,126,.95)');
          fus.addColorStop(.45, 'rgba(164,178,192,.97)');
          fus.addColorStop(1, 'rgba(66,74,84,.98)');
          ctx.fillStyle = fus;
          ctx.beginPath();
          ctx.moveTo(28, 0);
          ctx.lineTo(11, -9.8);
          ctx.lineTo(-20, -9.2);
          ctx.lineTo(-34, -2.2);
          ctx.lineTo(-34, 2.2);
          ctx.lineTo(-20, 9.2);
          ctx.lineTo(11, 9.8);
          ctx.closePath();
          ctx.fill();

          const wing = ctx.createLinearGradient(-34, 0, 20, 0);
          wing.addColorStop(0, 'rgba(72,82,94,.95)');
          wing.addColorStop(1, 'rgba(138,148,162,.96)');
          ctx.fillStyle = wing;
          ctx.beginPath();
          ctx.moveTo(-7, -2);
          ctx.lineTo(-40, -14);
          ctx.lineTo(-28, -4);
          ctx.lineTo(-8, 0);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(-7, 2);
          ctx.lineTo(-40, 14);
          ctx.lineTo(-28, 4);
          ctx.lineTo(-8, 0);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = 'rgba(170,188,208,.94)';
          ctx.fillRect(12, -2.3, 12, 4.6);
          ctx.fillStyle = 'rgba(32,50,68,.86)';
          ctx.fillRect(14, -1.5, 8.8, 3);
          ctx.fillStyle = 'rgba(228,244,255,.58)';
          ctx.fillRect(14.5, -1.9, 5.2, .9);

          ctx.strokeStyle = 'rgba(54,64,74,.62)';
          ctx.lineWidth = .9;
          for (let i = -2; i <= 2; i++) {
            ctx.beginPath();
            ctx.moveTo(-20, i * 2.9);
            ctx.lineTo(18, i * 2.3);
            ctx.stroke();
          }
          ctx.strokeStyle = 'rgba(190,208,222,.42)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(-28, 0);
          ctx.lineTo(20, 0);
          ctx.stroke();

          ctx.fillStyle = 'rgba(255,206,156,.9)';
          ctx.fillRect(-38, -2.6, 7.6, 5.2);
          ctx.fillStyle = `rgba(126,236,255,${.46 + Math.sin(S.time * 9 + r.id) * .18})`;
          ctx.fillRect(-39.4, -1.2, 2.7, 2.4);

          ctx.fillStyle = 'rgba(44,52,60,.8)';
          ctx.fillRect(-18, -12.2, 37, 2.4);
          ctx.fillStyle = 'rgba(255,102,84,.95)';
          ctx.fillRect(-17.3, -11.6, 35.6 * hpRatio, 1.2);

          if (damage > .08) {
            ctx.strokeStyle = `rgba(44,24,18,${damage * .7})`;
            ctx.lineWidth = 1.1;
            ctx.beginPath();
            ctx.moveTo(-8, -5);
            ctx.lineTo(2, -2);
            ctx.moveTo(-6, 5);
            ctx.lineTo(4, 1);
            ctx.stroke();
          }

          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          const flame = .32 + .68 * Math.max(0, Math.sin(S.time * 17 + r.id));
          ctx.fillStyle = `rgba(255,146,102,${flame * .7})`;
          ctx.beginPath();
          ctx.ellipse(-42, 0, 6.2, 2.8, 0, 0, TAU);
          ctx.fill();
          ctx.restore();
          ctx.restore();
        }
      }

      function drawDemon() {
        const d = S.demon;
        if (!d) return;
        ctx.save();
        ctx.translate(d.x, d.y);
        const wing = 1 + Math.sin(S.time * 11 + d.ph) * .1,
          beat = .45 + .55 * Math.max(0, Math.sin(S.time * 8.6 + d.ph));

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const aura = ctx.createRadialGradient(0, 2, 6, 0, 4, 68);
        aura.addColorStop(0, `rgba(255,90,76,${.24 + beat * .2})`);
        aura.addColorStop(.62, 'rgba(188,34,32,.12)');
        aura.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = aura;
        ctx.beginPath();
        ctx.ellipse(0, 7, 60, 21, 0, 0, TAU);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.scale(wing, 1);
        const membraneL = ctx.createLinearGradient(-52, -20, -5, 10);
        membraneL.addColorStop(0, 'rgba(64,10,12,.95)');
        membraneL.addColorStop(1, 'rgba(140,24,24,.95)');
        ctx.fillStyle = membraneL;
        ctx.beginPath();
        ctx.moveTo(-9, -4);
        ctx.quadraticCurveTo(-36, -31, -60, -14);
        ctx.quadraticCurveTo(-47, -2, -26, 8);
        ctx.closePath();
        ctx.fill();
        const membraneR = ctx.createLinearGradient(52, -20, 5, 10);
        membraneR.addColorStop(0, 'rgba(64,10,12,.95)');
        membraneR.addColorStop(1, 'rgba(140,24,24,.95)');
        ctx.fillStyle = membraneR;
        ctx.beginPath();
        ctx.moveTo(9, -4);
        ctx.quadraticCurveTo(36, -31, 60, -14);
        ctx.quadraticCurveTo(47, -2, 26, 8);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = 'rgba(188,52,48,.52)';
        ctx.lineWidth = 1.1;
        ctx.beginPath();
        ctx.moveTo(-11, -3);
        ctx.lineTo(-42, -16);
        ctx.moveTo(-15, 1);
        ctx.lineTo(-36, 2);
        ctx.moveTo(11, -3);
        ctx.lineTo(42, -16);
        ctx.moveTo(15, 1);
        ctx.lineTo(36, 2);
        ctx.stroke();
        ctx.restore();

        const core = ctx.createLinearGradient(0, -24, 0, 24);
        core.addColorStop(0, 'rgba(238,70,58,.97)');
        core.addColorStop(.45, 'rgba(164,22,22,.97)');
        core.addColorStop(1, 'rgba(86,10,12,.98)');
        ctx.fillStyle = core;
        ctx.beginPath();
        ctx.moveTo(0, -25);
        ctx.lineTo(16, -6);
        ctx.lineTo(13, 16);
        ctx.lineTo(0, 26);
        ctx.lineTo(-13, 16);
        ctx.lineTo(-16, -6);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'rgba(84,8,8,.78)';
        ctx.beginPath();
        ctx.moveTo(-3, -19);
        ctx.lineTo(-10, -31);
        ctx.lineTo(-2, -25);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(3, -19);
        ctx.lineTo(10, -31);
        ctx.lineTo(2, -25);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'rgba(24,6,6,.8)';
        ctx.beginPath();
        ctx.ellipse(0, -5.5, 8, 3.6, 0, 0, TAU);
        ctx.fill();
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = `rgba(255,198,146,${.55 + beat * .4})`;
        ctx.beginPath();
        ctx.arc(-4.8, -5.5, 2.2, 0, TAU);
        ctx.arc(4.8, -5.5, 2.2, 0, TAU);
        ctx.fill();
        ctx.fillStyle = `rgba(255,106,84,${.35 + beat * .35})`;
        ctx.beginPath();
        ctx.arc(0, 5.8, 5.1, 0, TAU);
        ctx.fill();
        ctx.restore();

        ctx.fillStyle = `rgba(255,122,90,${.38 + beat * .35})`;
        ctx.beginPath();
        ctx.moveTo(0, 24);
        ctx.lineTo(3.5, 36);
        ctx.lineTo(0, 33);
        ctx.lineTo(-3.5, 36);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawMissiles(arr, en) {
        for (const m of arr) {
          ctx.save();
          if (m.trail.length > 1) {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            const isCruise = m.v === 'cruise';
            const isCarrier = m.v === 'carrier';
            const isDrone = m.v === 'drone';
            ctx.lineWidth = en ? isCarrier ? 4.6 : isCruise ? 3.8 : isDrone ? 2.2 : 3.2 : 2.6;
            for (let i = 0; i < m.trail.length - 1; i++) {
              const a = m.trail[i],
                b = m.trail[i + 1],
                al = (1 - i / m.trail.length) * (en ? .72 : .82);
              if (!en) ctx.strokeStyle = `rgba(124,245,255,${al})`;
              else if (isCruise) ctx.strokeStyle = `rgba(116,255,210,${al})`;
              else if (isCarrier) ctx.strokeStyle = `rgba(255,182,132,${al})`;
              else if (isDrone) ctx.strokeStyle = `rgba(166,246,255,${al})`;
              else ctx.strokeStyle = `rgba(255,182,124,${al})`;
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.stroke();
            }
          }
          const vx = en ? (m.cv ?? m.vx) : m.vx,
            vy = en ? (m.cy ?? m.vy) : m.vy,
            ang = Math.atan2(vy, vx);
          ctx.translate(m.x, m.y);
          ctx.rotate(ang);
          const isStealth = m.v === 'stealth';
          const isCruise = m.v === 'cruise';
          const isCarrier = m.v === 'carrier';
          const isDrone = m.v === 'drone';
          const isSpit = m.v === 'spit';
          const isHell = m.v === 'hell';
          const stealthA = isStealth ? Math.pow(Math.max((m.y + 100) / (S.groundY + 100), 0), 3) * .55 + .05 : 1;
          ctx.globalAlpha *= stealthA;
          const bodyColor = en ? vColor(m.v) : C.player;
          const baseGlow = en ? 16 : 14;
          ctx.shadowBlur = baseGlow * (isStealth ? 0.2 : 1);
          ctx.shadowColor = en ? bodyColor : 'rgba(140,255,255,.95)';

          if (!en) {
            if (m.hr) {
              ctx.fillStyle = 'rgba(255,168,132,.97)';
              ctx.beginPath();
              ctx.moveTo(8.8, 0);
              ctx.lineTo(0, -2.5);
              ctx.lineTo(-7.4, 0);
              ctx.lineTo(0, 2.5);
              ctx.closePath();
              ctx.fill();
              ctx.fillStyle = 'rgba(255,236,210,.95)';
              ctx.fillRect(5.2, -1, 4.4, 2);
              ctx.fillStyle = 'rgba(255,122,86,.84)';
              ctx.fillRect(-10.4, -1, 5.5, 2);
            } else {
              ctx.fillStyle = 'rgba(162,244,255,.96)';
              ctx.beginPath();
              ctx.moveTo(12, 0);
              ctx.lineTo(-8, -3.2);
              ctx.lineTo(-12, 0);
              ctx.lineTo(-8, 3.2);
              ctx.closePath();
              ctx.fill();
              ctx.fillStyle = 'rgba(214,255,255,.98)';
              ctx.fillRect(8, -1.2, 6.5, 2.4);
              ctx.fillStyle = 'rgba(124,245,255,.8)';
              ctx.fillRect(-15, -1.2, 7.5, 2.4);
              ctx.fillStyle = 'rgba(154,255,255,.55)';
              ctx.beginPath();
              ctx.ellipse(-17.5, 0, 4.8, 2.4, 0, 0, TAU);
              ctx.fill();
            }
          } else if (isCarrier) {
            const hpRatio = clamp((m.hp ?? 1) / 3, 0, 1);
            const dmg = 1 - hpRatio;
            const carBody = ctx.createLinearGradient(-17, -8, 18, 8);
            carBody.addColorStop(0, 'rgba(90,100,112,.97)');
            carBody.addColorStop(.4, 'rgba(176,186,198,.98)');
            carBody.addColorStop(1, 'rgba(62,72,84,.98)');
            ctx.fillStyle = carBody;
            ctx.beginPath();
            ctx.moveTo(16, 0);
            ctx.lineTo(5, -6);
            ctx.lineTo(-11, -6.8);
            ctx.lineTo(-16, 0);
            ctx.lineTo(-11, 6.8);
            ctx.lineTo(5, 6);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = 'rgba(196,214,234,.88)';
            ctx.fillRect(8.4, -1.5, 7.8, 3);
            ctx.fillStyle = 'rgba(40,56,72,.75)';
            ctx.fillRect(9.4, -1, 4.6, 2);
            ctx.strokeStyle = 'rgba(42,54,66,.64)';
            ctx.lineWidth = .8;
            ctx.beginPath();
            for (let i = -2; i <= 2; i++) {
              ctx.moveTo(-11, i * 2.3);
              ctx.lineTo(10, i * 2);
            }
            ctx.stroke();
            ctx.fillStyle = 'rgba(52,58,68,.78)';
            ctx.fillRect(-9, -8.8, 18, 2.2);
            ctx.fillStyle = 'rgba(255,96,86,.96)';
            ctx.fillRect(-8.4, -8.2, 16.8 * hpRatio, 1.2);
            ctx.fillStyle = `rgba(126,238,255,${.4 + Math.sin(S.time * 13 + m.id) * .16})`;
            ctx.fillRect(-18.6, -1.25, 6.3, 2.5);
            ctx.fillRect(-23, -1, 4.4, 2);
            if (dmg > .08) {
              ctx.strokeStyle = `rgba(48,30,24,${dmg * .72})`;
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(-4, 3.2);
              ctx.lineTo(2, 1.1);
              ctx.moveTo(-2, -2.6);
              ctx.lineTo(4, -1.2);
              ctx.stroke();
            }
          } else if (isCruise) {
            ctx.fillStyle = 'rgba(126,255,220,.94)';
            ctx.beginPath();
            ctx.moveTo(14, 0);
            ctx.lineTo(1, -4.3);
            ctx.lineTo(-12, -4.3);
            ctx.lineTo(-14, 0);
            ctx.lineTo(-12, 4.3);
            ctx.lineTo(1, 4.3);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = 'rgba(212,255,244,.94)';
            ctx.fillRect(9, -1.3, 5.5, 2.6);
            ctx.fillStyle = 'rgba(92,232,198,.72)';
            ctx.fillRect(-14, -1.4, 8.4, 2.8);
            ctx.fillStyle = 'rgba(102,255,218,.5)';
            ctx.beginPath();
            ctx.ellipse(-18, 0, 4.4, 2.1, 0, 0, TAU);
            ctx.fill();
          } else if (isDrone) {
            const dg = ctx.createLinearGradient(-10, -4, 9, 4);
            dg.addColorStop(0, 'rgba(76,100,120,.96)');
            dg.addColorStop(.45, 'rgba(174,212,236,.97)');
            dg.addColorStop(1, 'rgba(58,74,92,.97)');
            ctx.fillStyle = dg;
            ctx.beginPath();
            ctx.moveTo(9, 0);
            ctx.lineTo(1.2, -4.6);
            ctx.lineTo(-8, 0);
            ctx.lineTo(1.2, 4.6);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = 'rgba(44,62,78,.88)';
            ctx.fillRect(-4.8, -2.7, 6, 5.4);
            ctx.fillStyle = 'rgba(204,238,255,.96)';
            ctx.fillRect(4.8, -1.1, 4.3, 2.2);
            ctx.fillStyle = 'rgba(144,220,255,.84)';
            ctx.fillRect(-10, -1, 4.8, 2);
            ctx.fillStyle = `rgba(136,242,255,${.38 + Math.sin(S.time * 12 + m.id) * .2})`;
            ctx.fillRect(-11.4, -0.7, 2.1, 1.4);
            ctx.fillStyle = 'rgba(236,250,255,.95)';
            ctx.beginPath();
            ctx.arc(1, 0, 1.6, 0, TAU);
            ctx.fill();
          } else if (isSpit || isHell) {
            ctx.fillStyle = isHell ? 'rgba(255,74,58,.98)' : 'rgba(255,142,102,.96)';
            ctx.beginPath();
            ctx.moveTo(11, 0);
            ctx.lineTo(0, -3.6);
            ctx.lineTo(-9, 0);
            ctx.lineTo(0, 3.6);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = isHell ? 'rgba(255,220,160,.95)' : 'rgba(255,234,206,.92)';
            ctx.fillRect(7.2, -1.2, 5.2, 2.4);
            ctx.fillStyle = isHell ? 'rgba(255,108,72,.7)' : 'rgba(255,170,120,.65)';
            ctx.fillRect(-13, -1.2, 6.5, 2.4);
          } else {
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(0, 0, en ? 4.9 : 4, en ? 3.2 : 2.7, 0, 0, TAU);
            ctx.fill();
            ctx.fillStyle = en ? 'rgba(255,240,205,.95)' : 'rgba(214,255,255,.95)';
            ctx.fillRect((en ? 3.8 : 3.2), -1.2, en ? 7 : 6, 2.4);
            if (en && m.v === 'heavy') {
              ctx.fillStyle = 'rgba(255,104,88,.72)';
              ctx.beginPath();
              ctx.arc(0, 0, 7.4, 0, TAU);
              ctx.fill();
            }
          }
          ctx.globalAlpha *= .48;
          ctx.fillStyle = en ? isHell ? 'rgba(255,86,66,.92)' : 'rgba(255,180,120,.8)' : m.hr ? 'rgba(255,132,98,.88)' : 'rgba(142,248,255,.82)';
          ctx.fillRect(-18, -1.1, 14, 2.2);
          ctx.restore();
        }
      }

      function drawExpl() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const e of S.expl) {
          if (e.r <= 1) continue;
          const p = e.el / e.life,
            g = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.r);
          if (e.player) {
            if (e.emp) {
              g.addColorStop(0, 'rgba(210,248,255,.86)');
              g.addColorStop(.35, 'rgba(126,244,255,.5)');
              g.addColorStop(.75, 'rgba(70,175,255,.28)');
              g.addColorStop(1, 'rgba(32,78,152,0)');
            } else {
              g.addColorStop(0, 'rgba(196,255,255,.94)');
              g.addColorStop(.4, 'rgba(92,240,255,.56)');
              g.addColorStop(1, 'rgba(42,88,150,0)');
            }
          } else {
            g.addColorStop(0, 'rgba(255,224,172,.95)');
            g.addColorStop(.42, 'rgba(255,128,64,.55)');
            g.addColorStop(1, 'rgba(90,25,15,0)');
          }
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.r, 0, TAU);
          ctx.fill();
          const ringA = (1 - p) * .45;
          if (ringA > .02) {
            ctx.strokeStyle = e.emp ? `rgba(132,240,255,${ringA})` : e.player ? `rgba(172,248,255,${ringA})` : `rgba(255,182,120,${ringA})`;
            ctx.lineWidth = e.emp ? 2.2 : 1.6;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r * (1.05 + p * .35), 0, TAU);
            ctx.stroke();
          }
          if (e.emp) {
            ctx.strokeStyle = `rgba(140,242,255,${.45 * (1 - p)})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r * .92, 0, TAU);
            ctx.stroke();
          }
        }
        ctx.restore();
      }

      function drawSmoke() {
        for (const s of S.smoke) {
          const p = s.el / s.life,
            a = s.a * (1 - p);
          if (a <= .01) continue;
          const r = s.br * (.85 + p * 1.8),
            g = ctx.createRadialGradient(s.x, s.y, r * .2, s.x, s.y, r);
          g.addColorStop(0, `rgba(168,184,220,${a * .44})`);
          g.addColorStop(.65, `rgba(88,102,140,${a * .24})`);
          g.addColorStop(1, 'rgba(10,16,28,0)');
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(s.x, s.y, r, 0, TAU);
          ctx.fill();
        }
      }

      function drawSparks() {
        for (const s of S.sparks) {
          const a = 1 - s.el / s.life;
          if (a <= 0) continue;
          ctx.fillStyle = s.emp ? `rgba(132,238,255,${a})` : s.player ? `rgba(142,252,255,${a})` : `rgba(255,150,86,${a})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.size, 0, TAU);
          ctx.fill();
        }
      }

      function drawTrails() {
        for (const p of S.trails) {
          const a = 1 - p.el / p.life;
          if (a <= 0) continue;
          const ang = Math.atan2(p.dy || p.vy, p.dx || p.vx),
            len = (p.v === 'phalanx' ? 15 : (p.en ? 9 : 7)) * (1 - a * .35);
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(ang);
          if (p.v === 'phalanx') {
            ctx.fillStyle = `rgba(255,222,156,${a * .9})`;
          } else if (!p.en) {
            if (p.v === 'hellRaiser') ctx.fillStyle = `rgba(255,148,102,${a * .86})`;
            else ctx.fillStyle = `rgba(132,248,255,${a * .8})`;
          }
          else {
            const isStealth = p.v === 'stealth';
            const stealthA = isStealth ? Math.pow(Math.max((p.y + 100) / (S.groundY + 100), 0), 3) * .2 + .02 : 1;
            const c = vColor(p.v),
              warm = c === C.fast || c === C.enemy || c === C.heavy || c === C.split || c === C.decoy || p.v === 'carrier';
            ctx.fillStyle = warm ? `rgba(255,170,104,${a * .75 * stealthA})` : `rgba(244,145,252,${a * .7 * stealthA})`;
            if (p.v === 'cruise') ctx.fillStyle = `rgba(132,255,222,${a * .76 * stealthA})`;
            if (p.v === 'drone') ctx.fillStyle = `rgba(162,238,255,${a * .72 * stealthA})`;
            if (p.v === 'spit') ctx.fillStyle = `rgba(255,150,102,${a * .8 * stealthA})`;
            if (p.v === 'hell') ctx.fillStyle = `rgba(255,86,66,${a * .88 * stealthA})`;
          }
          ctx.beginPath();
          ctx.ellipse(0, 0, p.size * 1.25, p.size * .9, 0, 0, TAU);
          ctx.fill();
          ctx.globalAlpha *= p.v === 'phalanx' ? .85 : .65;
          ctx.fillRect(-len * .92, -p.size * .36, len, p.size * .72);
          ctx.restore();
        }
      }

      function drawDebris() {
        if (!S.debris.length) return;
        ctx.save();
        for (const d of S.debris) {
          const p = d.el / d.life,
            a = (1 - p) * .95;
          ctx.save();
          ctx.translate(d.x, d.y);
          ctx.rotate(d.rot);
          if (d.ember) {
            ctx.fillStyle = `rgba(255,176,108,${a * (d.hot + .25)})`;
            ctx.shadowBlur = 10 * d.hot;
            ctx.shadowColor = `rgba(255,166,90,${a})`;
          } else {
            ctx.fillStyle = `rgba(144,128,130,${a * .8})`;
          }
          ctx.fillRect(-d.w * .5, -d.h * .5, d.w, d.h);
          ctx.restore();
        }
        ctx.restore();
      }

      function drawShock() {
        if (!S.shock.length) return;
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        for (const s of S.shock) {
          const p = s.el / s.life,
            a = (1 - p) * s.alpha;
          if (a <= .01) continue;
          ctx.strokeStyle = s.emp ? `rgba(132,236,255,${a})` : `rgba(255,188,146,${a})`;
          ctx.lineWidth = s.emp ? 3.2 : 2.2;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r, 0, TAU);
          ctx.stroke();
          ctx.strokeStyle = s.emp ? `rgba(86,198,255,${a * .6})` : `rgba(255,126,86,${a * .55})`;
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r * .82, 0, TAU);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawLightBursts() {
        if (!S.lightBursts.length) return;
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        for (const l of S.lightBursts) {
          const p = l.el / l.life,
            a = (1 - p) * .42;
          if (a <= .01) continue;
          const r = l.r * (1 + p * .55);
          const g = ctx.createRadialGradient(l.x, l.y, 0, l.x, l.y, r);
          if (l.warm) {
            g.addColorStop(0, `rgba(255,196,144,${a})`);
            g.addColorStop(1, 'rgba(255,110,76,0)');
          } else {
            g.addColorStop(0, `rgba(156,235,255,${a})`);
            g.addColorStop(1, 'rgba(86,142,255,0)');
          }
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(l.x, l.y, r, 0, TAU);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawBloom() {
        if (!bloomCtx) return;
        bloomCtx.clearRect(0, 0, S.w, S.h);
        bloomCtx.globalCompositeOperation = 'source-over';
        bloomCtx.save();
        bloomCtx.globalCompositeOperation = 'lighter';
        for (const e of S.expl) {
          const a = 1 - e.el / e.life;
          if (a <= 0) continue;
          const r = e.r * (e.emp ? 1.18 : 1.0);
          const g = bloomCtx.createRadialGradient(e.x, e.y, 0, e.x, e.y, r);
          if (e.player) {
            g.addColorStop(0, `rgba(180,250,255,${a * .7})`);
            g.addColorStop(1, 'rgba(78,130,255,0)');
          } else {
            g.addColorStop(0, `rgba(255,208,136,${a * .65})`);
            g.addColorStop(1, 'rgba(255,96,72,0)');
          }
          bloomCtx.fillStyle = g;
          bloomCtx.beginPath();
          bloomCtx.arc(e.x, e.y, r, 0, TAU);
          bloomCtx.fill();
        }
        for (const t of S.trails) {
          const a = 1 - t.el / t.life;
          if (a <= 0) continue;
          bloomCtx.fillStyle = t.v === 'phalanx' ? `rgba(255,232,178,${a * .55})` : t.en ? `rgba(255,172,120,${a * .42})` : t.v === 'hellRaiser' ? `rgba(255,162,118,${a * .55})` : `rgba(132,248,255,${a * .5})`;
          bloomCtx.beginPath();
          bloomCtx.arc(t.x, t.y, 2.1 + t.size * 1.6, 0, TAU);
          bloomCtx.fill();
        }
        bloomCtx.restore();
        const blur = 6 + S.danger * 10 + clamp(S.flash * 22, 0, 16);
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.filter = `blur(${blur}px)`;
        ctx.globalAlpha = .28 + S.danger * .24;
        ctx.drawImage(bloomCanvas, 0, 0);
        ctx.filter = `blur(${Math.max(2, blur * .45)}px)`;
        ctx.globalAlpha = .18 + S.danger * .2;
        ctx.drawImage(bloomCanvas, 0, 0);
        ctx.filter = 'none';
        ctx.restore();
      }

      function drawCross() {
        if (S.intro || S.gameOver) return;
        const x = S.mouse.x,
          y = S.mouse.y;
        let hot = false;
        for (const m of S.enemy) {
          const dx = m.x - x,
            dy = m.y - y;
          if (dx * dx + dy * dy < 170 * 170) {
            hot = true;
            break;
          }
        }
        if (!hot)
          for (const u of S.ufo) {
            const dx = u.x - x,
              dy = u.y - y;
            if (dx * dx + dy * dy < 190 * 190) {
              hot = true;
              break;
            }
          }
        if (!hot)
          for (const r of S.raiders) {
            const dx = r.x - x,
              dy = r.y - y;
            if (dx * dx + dy * dy < 210 * 210) {
              hot = true;
              break;
            }
          }
        if (!hot && S.demon) {
          const dx = S.demon.x - x,
            dy = S.demon.y - y;
          if (dx * dx + dy * dy < 240 * 240) hot = true;
        }
        ctx.save();
        ctx.translate(x, y);
        ctx.strokeStyle = hot ? 'rgba(255,156,96,.82)' : 'rgba(130,236,255,.8)';
        ctx.lineWidth = hot ? 1.8 : 1.4;
        ctx.beginPath();
        ctx.arc(0, 0, 14, 0, TAU);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-21, 0);
        ctx.lineTo(-8, 0);
        ctx.moveTo(8, 0);
        ctx.lineTo(21, 0);
        ctx.moveTo(0, -21);
        ctx.lineTo(0, -8);
        ctx.moveTo(0, 8);
        ctx.lineTo(0, 21);
        ctx.stroke();
        ctx.restore();
      }

      function drawHud() {
        const alive = S.cities.filter(c => c.alive).length,
          pending = Math.max(0, S.wavePlan.length - S.spawnI),
          ufoCount = S.ufo.length,
          raiderCount = S.raiders.length,
          host = S.enemy.length + ufoCount + raiderCount + (S.demon ? 1 : 0),
          ammo = S.bases.map(b => `${b.id}:${b.destroyed ? 'X' : b.ammo}`).join('  '),
          ph = S.phalanx ? S.phalanx.destroyed ? 'X' : S.phalanx.ammo : '--',
          hr = S.hellRaiser ? S.hellRaiser.destroyed ? 'X' : `${hellRaiserStatus()} ${Math.max(0, Math.floor(S.hellRaiser.ammo))}` : '--',
          hrHp = S.hellRaiser && hellRaiserVulnerable() ? `${Math.ceil(S.hellRaiser.hp)}/${S.hellRaiser.maxHp}` : '--',
          dbg = S.debug.enabled ? `ON (${Object.keys(S.debug.waves).length}W)` : 'OFF',
          ammoLeft = S.bases.reduce((n, b) => n + (b.destroyed ? 0 : b.ammo), 0) + (S.phalanx && !S.phalanx.destroyed ? S.phalanx.ammo : 0),
          bars = 14,
          fill = Math.round(S.danger * bars),
          bar = '#'.repeat(fill) + '-'.repeat(bars - fill),
          volText = audio.isMuted() ? 'MUTED' : Math.round(audio.getVolume() * 100) + '%',
          weather = `${S.weather.mode.toUpperCase()} ${Math.round(S.weather.intensity * 100)}%`,
          up = `YLD x${S.upgrades.blastScale.toFixed(1)} | RLD x${S.upgrades.reloadMult.toFixed(2)} | EMP x${S.upgrades.empScale.toFixed(1)}`;
        hud.innerHTML = `Wave <strong>${S.level}</strong>  |  Score <strong>${S.score}</strong>  |  Combo <strong>x${Math.max(1, S.combo)}</strong>  |  Max <strong>x${Math.max(1, S.maxCombo)}</strong>  |  <span class="dim">Vol</span> <strong>${volText}</strong><br>` +
          `<span class="dim">Cities</span> <strong>${alive}</strong>  |  <span class="dim">EMP</span> <strong>${S.emp}</strong>  |  <span class="dim">Ammo Left</span> <strong>${ammoLeft}</strong>  |  <span class="dim">Mode</span> <strong>${S.auto ? 'AUTO' : 'MANUAL'}</strong><br>` +
          `<span class="dim">Hostiles</span> <strong>${host}</strong>  |  <span class="dim">UFO</span> <strong>${ufoCount}</strong>  |  <span class="dim">Raider</span> <strong>${raiderCount}</strong>  |  <span class="dim">Pending</span> <strong>${pending}</strong>  |  <span class="dim">Bases</span> <strong>${ammo}</strong>  |  <span class="dim">Phalanx</span> <strong>${ph}</strong><br>` +
          `<span class="dim">Hell Raiser</span> <strong>${hr}</strong>  |  <span class="dim">HR HP</span> <strong>${hrHp}</strong><br>` +
          `<span class="dim">Debug Telemetry</span> <strong>${dbg}</strong><br>` +
          `<span class="dim">Threat</span> <strong style="color:${S.danger > .66 ? '#ff9b66' : '#89f4ff'}">[${bar}]</strong> <span class="dim">${Math.round(S.danger * 100)}%</span>  |  <span class="dim">WX</span> <strong>${weather}</strong><br>` +
          `<span class="dim">Upgrades</span> <strong>${up}</strong>`;
      }

      function drawOver() {
        ctx.save();
        ctx.textAlign = 'center';
        if (S.msgT > 0 && !S.gameOver) {
          const a = clamp(S.msgT, 0, 1),
            w = Math.min(420, S.w * .65),
            h = 48;
          ctx.fillStyle = `rgba(2,12,24,${.56 * a})`;
          ctx.fillRect(S.w * .5 - w * .5, S.h * .08, w, h);
          ctx.strokeStyle = `rgba(106,194,255,${.45 * a})`;
          ctx.strokeRect(S.w * .5 - w * .5, S.h * .08, w, h);
          ctx.fillStyle = `rgba(236,247,255,${.95 * a})`;
          ctx.font = '700 20px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillText(S.msg, S.w * .5, S.h * .08 + 30);
        }
        if (S.noteT > 0) {
          const a = clamp(S.noteT, 0, 1);
          ctx.fillStyle = `rgba(140,232,255,${.8 * a})`;
          ctx.font = '700 24px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillText(S.note, S.w * .5, S.h * .16);
        }
        if (S.intro) {
          const w = Math.min(S.w * .84, 860),
            h = Math.min(S.h * .44, 360),
            x = S.w * .5 - w * .5,
            y = S.h * .33;
          ctx.fillStyle = 'rgba(2,8,18,.72)';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(110,190,255,.45)';
          ctx.strokeRect(x, y, w, h);
          ctx.fillStyle = '#d6efff';
          ctx.font = '700 38px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillText('MISSILE COMMAND: OVERDRIVE', S.w * .5, y + 68);
          ctx.font = '500 20px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillText('Hostiles now deploy fast, zigzag, splitter, and heavy warheads.', S.w * .5, y + 124);
          ctx.fillText('Use interceptors and EMP pulses to hold the line.', S.w * .5, y + 160);
          ctx.font = '600 17px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillText('LMB Fire   |   H Hell Raiser   |   C Toggle Auto Defense   |   E EMP Pulse', S.w * .5, y + 222);
          ctx.fillText('Click anywhere to begin', S.w * .5, y + 272);
        }
        if (S.gameOver) {
          const w = Math.min(S.w * .62, 720),
            h = 220,
            x = S.w * .5 - w * .5,
            y = S.h * .37;
          ctx.fillStyle = 'rgba(8,5,9,.72)';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(255,128,106,.4)';
          ctx.strokeRect(x, y, w, h);
          ctx.fillStyle = '#f5f5ff';
          ctx.font = '700 36px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillText('DEFENSE GRID LOST', S.w * .5, y + 64);
          ctx.font = '500 24px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillText(`Final Score: ${S.score}`, S.w * .5, y + 112);
          ctx.font = '500 18px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillText(`Best Combo: x${Math.max(1, S.maxCombo)}`, S.w * .5, y + 146);
          ctx.fillText('Click to restart', S.w * .5, y + 182);
        }

        if (S.shop && !S.gameOver) {
          const w = Math.min(S.w * .72, 820),
            h = Math.min(560, S.h * .84),
            x = S.w * .5 - w * .5,
            y = Math.max(12, S.h * .1);
          ctx.fillStyle = 'rgba(10,16,35,.85)';
          ctx.fillRect(x, y, w, h);
          ctx.strokeStyle = 'rgba(130,210,255,.5)';
          ctx.strokeRect(x, y, w, h);

          ctx.fillStyle = '#eaf5ff';
          ctx.font = '700 32px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillText(`WAVE ${S.level} COMPLETE - STRATEGY LINK`, S.w * .5, y + 54);

          ctx.font = '500 22px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillStyle = '#8ce8ff';
          ctx.fillText(`AVAILABLE FUNDS: ${S.score}`, S.w * .5, y + 96);

          const btnW = 340, btnH = 46;
          const bX = S.w * .5;
          ctx.font = '600 18px "Orbitron","Trebuchet MS",sans-serif';

          ctx.fillStyle = S.score >= 5000 ? 'rgba(70,130,200,.6)' : 'rgba(80,80,90,.6)';
          ctx.fillRect(bX - btnW / 2, y + 140, btnW, btnH);
          ctx.strokeRect(bX - btnW / 2, y + 140, btnW, btnH);
          ctx.fillStyle = S.score >= 5000 ? '#fff' : '#aaa';
          ctx.fillText('1. REBUILD CITY (5000)', bX, y + 168);

          ctx.fillStyle = S.score >= 2500 ? 'rgba(70,130,200,.6)' : 'rgba(80,80,90,.6)';
          ctx.fillRect(bX - btnW / 2, y + 200, btnW, btnH);
          ctx.strokeRect(bX - btnW / 2, y + 200, btnW, btnH);
          ctx.fillStyle = S.score >= 2500 ? '#fff' : '#aaa';
          ctx.fillText('2. BUY EMP (2500)', bX, y + 228);

          ctx.fillStyle = S.score >= 4000 ? 'rgba(70,130,200,.6)' : 'rgba(80,80,90,.6)';
          ctx.fillRect(bX - btnW / 2, y + 260, btnW, btnH);
          ctx.strokeRect(bX - btnW / 2, y + 260, btnW, btnH);
          ctx.fillStyle = S.score >= 4000 ? '#fff' : '#aaa';
          ctx.fillText('3. WARHEAD YIELD (4000)', bX, y + 288);

          ctx.fillStyle = S.score >= 3500 ? 'rgba(70,130,200,.6)' : 'rgba(80,80,90,.6)';
          ctx.fillRect(bX - btnW / 2, y + 320, btnW, btnH);
          ctx.strokeRect(bX - btnW / 2, y + 320, btnW, btnH);
          ctx.fillStyle = S.score >= 3500 ? '#fff' : '#aaa';
          ctx.fillText('4. RELOAD BOOST (3500)', bX, y + 348);

          ctx.fillStyle = S.score >= 3600 ? 'rgba(70,130,200,.6)' : 'rgba(80,80,90,.6)';
          ctx.fillRect(bX - btnW / 2, y + 380, btnW, btnH);
          ctx.strokeRect(bX - btnW / 2, y + 380, btnW, btnH);
          ctx.fillStyle = S.score >= 3600 ? '#fff' : '#aaa';
          ctx.fillText('5. EMP AMPLIFIER (3600)', bX, y + 408);

          ctx.fillStyle = '#bdf4ff';
          ctx.font = '700 22px "Orbitron","Trebuchet MS",sans-serif';
          ctx.fillText(`COMMENCING NEXT WAVE IN ${Math.max(0, Math.ceil(S.shopTimer))}s`, bX, y + 486);

          ctx.font = '14px sans-serif';
          ctx.fillStyle = '#8ce8ff';
          ctx.fillText('Press SPACE to skip, or 1/2/3/4/5 to purchase upgrades via keyboard.', bX, y + 520);
        }

        ctx.restore();
      }

      function postFx() {
        const v = ctx.createRadialGradient(S.w * .5, S.h * .5, S.h * .15, S.w * .5, S.h * .5, S.h * .85);
        v.addColorStop(0, 'rgba(0,0,0,0)');
        v.addColorStop(1, 'rgba(0,0,0,.42)');
        ctx.fillStyle = v;
        ctx.fillRect(0, 0, S.w, S.h);
        ctx.save();
        ctx.globalAlpha = .06 + S.danger * .05;
        ctx.fillStyle = '#6ab5ff';
        for (let y = 0; y < S.h; y += 3) ctx.fillRect(0, y, S.w, 1);
        ctx.restore();
        if (S.flash > .01) {
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          ctx.fillStyle = `rgba(160,218,255,${S.flash * 1.1})`;
          ctx.fillRect(0, 0, S.w, S.h);
          const flashG = ctx.createLinearGradient(0, S.horizonY, 0, S.h);
          flashG.addColorStop(0, `rgba(255,142,106,${S.flash * 0.85})`);
          flashG.addColorStop(1, `rgba(255,142,106,0)`);
          ctx.fillStyle = flashG;
          ctx.fillRect(0, S.horizonY, S.w, S.h - S.horizonY);
          ctx.restore();
        }
        if (S.danger > .55) {
          ctx.save();
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = `rgba(255,80,60,${(S.danger - .55) * .22})`;
          ctx.fillRect(0, 0, S.w, S.h);
          ctx.restore();
        }
        if (S.weather.mode === 'ash') {
          ctx.save();
          ctx.globalCompositeOperation = 'multiply';
          ctx.fillStyle = `rgba(164,110,70,${S.weather.intensity * .08})`;
          ctx.fillRect(0, 0, S.w, S.h);
          ctx.restore();
        }
        if (grainPattern) {
          ctx.save();
          ctx.globalAlpha = .04 + S.danger * .03 + (S.weather.mode === 'storm' ? S.weather.intensity * .03 : 0);
          ctx.fillStyle = grainPattern;
          ctx.translate(Math.sin(S.time * 12) * 6, Math.cos(S.time * 10) * 6);
          ctx.fillRect(-16, -16, S.w + 32, S.h + 32);
          ctx.restore();
        }
      }

      function draw() {
        const sx = S.shake > 0 ? rand(-S.shake, S.shake) : 0,
          sy = S.shake > 0 ? rand(-S.shake * .65, S.shake * .65) : 0;
        ctx.save();
        ctx.translate(sx, sy);
        drawSky();
        drawNeb();
        drawAur();
        drawClouds();
        drawStars();
        drawWeatherBack();
        drawMount();
        drawGround();
        drawLightBursts();
        drawCities();
        drawBases();
        drawHellRaiser();
        drawPhalanx();
        drawDemon();
        drawUfo();
        drawRaiders();
        drawTrails();
        drawWeatherFront();
        drawSmoke();
        drawMissiles(S.enemy, true);
        drawMissiles(S.player, false);
        drawExpl();
        drawSparks();
        drawDebris();
        drawShock();

        if (S.floatingTexts && S.floatingTexts.length) {
          for (const t of S.floatingTexts) {
            const a = clamp(t.life / 0.5, 0, 1);
            ctx.fillStyle = `rgba(255,255,255,${a})`;
            ctx.font = '700 22px "Orbitron","Trebuchet MS",sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(t.text, t.x, t.y);
          }
        }

        ctx.restore();
        drawBloom();
        drawCross();
        drawHud();
        drawOver();
        postFx();
      }

      function loop(ts) {
        const dt = (ts - S.last) / 1000 || .016;
        S.last = ts;
        update(Math.min(.033, dt));
        draw();
        requestAnimationFrame(loop);
      }
      const toCanvas = e => {
        const r = canvas.getBoundingClientRect();
        return {
          x: (e.clientX - r.left) * (canvas.width / r.width),
          y: (e.clientY - r.top) * (canvas.height / r.height)
        };
      };
      canvas.addEventListener('mousemove', e => {
        const p = toCanvas(e);
        S.mouse.x = p.x;
        S.mouse.y = p.y;
      });
      canvas.addEventListener('click', e => {
        audio.unlock();
        const p = toCanvas(e);
        S.mouse.x = p.x;
        S.mouse.y = p.y;
        if (S.intro) {
          resetGame();
          return;
        }
        if (S.gameOver) {
          resetGame();
          return;
        }
        launchPlayer(p.x, p.y);
      });
      canvas.addEventListener('contextmenu', e => {
        e.preventDefault();
        audio.unlock();
        useEMP();
      });
      addEventListener('keydown', e => {
        const k = e.key ? e.key.toLowerCase() : '';
        if (!k) return;
        if (/^[a-z0-9]$/.test(k)) {
          secretCode = (secretCode + k).slice(-8);
          if (secretCode.endsWith('666')) {
            audio.unlock();
            summonDaemon();
            secretCode = '';
            e.preventDefault();
            return;
          }
        }
        if (k === ']' || e.key === 'PageUp') {
          audio.unlock();
          jumpLevel(1);
          e.preventDefault();
          return;
        }
        if (k === '[' || e.key === 'PageDown') {
          audio.unlock();
          jumpLevel(-1);
          e.preventDefault();
          return;
        }
        if (k === 'f8') {
          audio.unlock();
          debugToggle();
          e.preventDefault();
          return;
        }
        if (k === 'f9') {
          audio.unlock();
          debugExport('wave');
          e.preventDefault();
          return;
        }
        if (k === 'f10') {
          audio.unlock();
          debugExport('session');
          e.preventDefault();
          return;
        }
        if (k === 'h') {
          audio.unlock();
          toggleHellRaiser();
          e.preventDefault();
          return;
        }
        if (k === 'c') {
          audio.unlock();
          S.auto = !S.auto;
          debugRecord('defense_mode', {
            auto: S.auto
          });
          S.msg = S.auto ? 'Auto defense enabled' : 'Auto defense disabled';
          S.msgT = 1.7;
          e.preventDefault();
          return;
        }
        if (k === 'e') {
          audio.unlock();
          useEMP();
          e.preventDefault();
          return;
        }
        if (k === 'm') {
          audio.unlock();
          audio.toggleMute();
          S.msg = audio.isMuted() ? 'Audio Muted' : 'Audio Unmuted';
          S.msgT = 1.0;
          e.preventDefault();
          return;
        }
        if (k === '-' || k === '_') {
          audio.unlock();
          audio.setVolume(audio.getVolume() - 0.1);
          S.msg = `Volume: ${Math.round(audio.getVolume() * 100)}%`;
          S.msgT = 1.0;
          e.preventDefault();
          return;
        }
        if (k === '=' || k === '+') {
          audio.unlock();
          audio.setVolume(audio.getVolume() + 0.1);
          S.msg = `Volume: ${Math.round(audio.getVolume() * 100)}%`;
          S.msgT = 1.0;
          e.preventDefault();
          return;
        }
        if (k === 'r') {
          audio.unlock();
          resetGame();
          e.preventDefault();
          return;
        }
        if (k === 'w' || k === ' ') {
          if (!S.shop) {
            S.selectedBase = null; S.msg = 'Auto Base Selection'; S.msgT = 0.8;
          }
        }
        if (S.shop) {
          if (k === '1' && S.score >= 5000) {
            const dead = S.cities.filter(c => !c.alive);
            if (dead.length > 0) {
              S.score -= 5000;
              const c = pick(dead.map(x => ({ v: x, w: 1 })));
              c.alive = true; c.ruin = null;
              audio.emp();
            } else { S.msg = 'All cities intact'; S.msgT = 1.0; }
          }
          else if (k === '2' && S.score >= 2500) {
            if (S.emp < S.empMax) { S.score -= 2500; S.emp++; audio.launch(0.5); }
            else { S.msg = 'EMP at maximum capacity'; S.msgT = 1.0; }
          }
          else if (k === '3' && S.score >= 4000) {
            S.score -= 4000;
            S.upgrades.blastScale = Math.min(2.8, S.upgrades.blastScale + 0.2);
            audio.impact(0.5, false);
            S.msg = `Warhead Yield ${S.upgrades.blastScale.toFixed(1)}x`;
            S.msgT = 1.0;
          }
          else if (k === '4' && S.score >= 3500) {
            S.score -= 3500;
            S.upgrades.reloadMult = Math.min(2.2, S.upgrades.reloadMult + 0.12);
            audio.launch(0.5);
            S.msg = `Reload Boost ${S.upgrades.reloadMult.toFixed(2)}x`;
            S.msgT = 1.0;
          }
          else if (k === '5' && S.score >= 3600) {
            S.score -= 3600;
            S.upgrades.empScale = Math.min(2.4, S.upgrades.empScale + 0.14);
            S.upgrades.phalanxEff = Math.min(2.0, S.upgrades.phalanxEff + 0.08);
            audio.emp();
            S.msg = `EMP/Phalanx Boost`;
            S.msgT = 1.0;
          }
          else if (k === ' ') {
            S.shop = false;
            S.level++;
            startWave(2.9);
          }
          e.preventDefault();
          return;
        }
        if (!S.shop) {
          if (k === '1' || k === 'a') { S.selectedBase = 0; S.msg = 'Base 1 Selected'; S.msgT = 0.8; }
          if (k === '2' || k === 's') { S.selectedBase = 1; S.msg = 'Base 2 Selected'; S.msgT = 0.8; }
          if (k === '3' || k === 'd') { S.selectedBase = 2; S.msg = 'Base 3 Selected'; S.msgT = 0.8; }
        }
      });
      addEventListener('resize', resize);
      resize();
      S.intro = true;
      S.last = performance.now();
      requestAnimationFrame(loop);
    })();
  </script>
</body>

</html>
